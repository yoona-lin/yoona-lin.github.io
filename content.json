{"meta":{"title":"yoona-lin","subtitle":null,"description":null,"author":"yoona-lin","url":"http://github.com"},"pages":[{"title":"个人简历","date":"2018-06-09T08:32:23.000Z","updated":"2018-07-24T17:31:33.678Z","comments":true,"path":"个人简历封面.html","permalink":"http://github.com/个人简历封面.html","excerpt":"","text":"点击more进行跳转more &gt;&gt;"},{"title":"","date":"2018-12-23T11:56:32.825Z","updated":"2018-12-23T11:56:32.825Z","comments":true,"path":"cover.html","permalink":"http://github.com/cover.html","excerpt":"","text":"Resume(简历封面) body{ margin: 0; padding: 0; /* height:500px; */ } a{ text-decoration: none; color: #000; } img{ opacity: 0.8; width: 100%; height:660px; position: absolute; top: 0; left: 0; z-index: -1; } .contain{ position: absolute; top: 22%; left: 26%; } .text{ font-size: 4em; color: #fff; margin-bottom: 6px; } .contain-text{ width: 400px; height: 300px; overflow: hidden; } .name{ font-size: 3em; border:1px solid rgb(232, 229, 219); border-radius: 20px ; background: rgba(232, 229, 219,0.8); margin-left: 30px; margin-top: 0px; width: 360px; height: 100px; text-align: center; line-height: 100px; cursor: pointer; transition: 0.8s; } .decoration{ font-size: 1.2em; color: rgb(85, 83, 83); border:1px solid rgb(232, 229, 219); border-radius: 0 0 20px 20px; background: rgba(214, 213, 210, 0.6); margin-left: 30px; margin-top: -300px; width: 360px; height: 60px; transition: 0.5s; text-align: center; } .name:hover{ border-radius: 20px 20px 0 0; background: rgba(140, 136, 135,0.9); } .contain-text:hover .decoration{ margin-top: 0px; } .name span{ font-size: 0.6em; } @media (max-width:890px){ body{ padding: 0; background: #9e9d9d; } .text{ font-size:3em; } .name{ font-size: 2em; border-radius: 20px; margin-left: 20px; width: 260px; height: 80px; line-height: 80px; transition: 0.3s; } .name span{ font-size: 0.4em; } .contain{ position: absolute; top: 20%; left: 10%; } .contain-text{ width: 300px; height: 200px; overflow: hidden; } .decoration{ font-size: 0.8em; color: rgb(85, 83, 83); border:1px solid rgb(232, 229, 219); border-radius: 0 0 20px 20px; background: rgba(214, 213, 210, 0.6); margin-left: 20px; margin-top: -300px; width: 260px; height: 60px; transition: 0.5s; text-align: center; } } @media (max-width:430px){ .text{ font-size: 2em; } } var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2773f7a57b6a920ffa37bc6295e2a9a8\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); Welcome to 林泽坚 个人简历 这是林泽坚个人简历封面图 点击查看更多信息！"},{"title":"","date":"2018-12-20T15:54:56.251Z","updated":"2018-12-20T15:54:56.251Z","comments":true,"path":"SQL数据库实验报告.html","permalink":"http://github.com/SQL数据库实验报告.html","excerpt":"","text":"数据库实验报告 window.onload = function (){ var myPDF = new PDFObject({ url: \"数据库实验报告.pdf\" }).embed(); }; 当您看到这行文字说明您并没有安装 Adobe Reader 或者 PDF 浏览器支持插件 请将PDF文件下载到本地阅读"},{"title":"","date":"2018-12-23T11:36:52.912Z","updated":"2018-12-23T11:36:52.912Z","comments":true,"path":"Resume.html","permalink":"http://github.com/Resume.html","excerpt":"","text":"Resume(简历) body{ margin: 0; padding: 0; background: rgb(236, 230, 240); } a{ text-decoration: none; color: #000; } .contain{ background: #312d40; width: 1000px; height:1100px; margin: auto; overflow: hidden; position: relative; } /* left */ .contain-left{ float: left; position: relative; background: rgb(83, 82, 93); width: 200px; height: 1000px; border-radius: 0 500px 500px 0; margin-top: 50px; } .left-more{ font-size: 10px; text-align: center; width: 20px; height: 68px; border-radius: 6px; background: #363434; color: rgb(210, 202, 204); opacity: 0.8; position: absolute; left: 2px; top: 30px; z-index: 2; display: none; } .left-header{ position: absolute; top:0px; left: 60px; width: 160px; height: 160px; overflow: hidden; border-radius: 80px; } .left-header img{ height: 100%; width: 100%; } .left-fooder{ position: absolute; top:180px; left: 20px; width: 162px; height:; background: rgb(83, 82, 93); } .left-content1 h3{ width: 120px; background: #fff; text-align: center; border-radius: 10px; margin-left: 50px; box-shadow: 2px 2px #b5a9a9; } .left-content1 p{ font-size: 12px; } .left-content2 p{ font-weight: bold; text-align: right; } .left-content2 span{ display: block; margin-top: -8px; text-align: right; font-size: 10px; } /* contain-center */ /* .contain-center{ float: left; width: 60px; height:1200px; background: rgb(130, 138, 140); } */ /* contain-right*/ .contain-right{ float: right; width: 740px; height: 1200px; position: relative; } .right-header{ position: absolute; top:-400px; right: -300px; width: 800px; height: 600px; overflow: hidden; border-radius:400px; background: rgb(83, 82, 93); } .right-header-text{ position: absolute; top:400px; right: 410px; color: #fff; } .right-header-text h1{ font-size: 40px; text-shadow: 2px 2px #b5a9a9; } .right-header-text p{ margin-left: 40px; font-weight: bold; } .right-content{ position: absolute; top:100px; left: 40px; color: #f9f1f1; font-size: 14px; } .right-content h2{ width: 140px; height: 40px; color: #000; margin-top: 30px; background: #fff; border-radius: 20px; line-height: 40px; text-align: center; box-shadow: 2px 2px #b5a9a9; } .right-content span{ font-weight: bold; padding: 0 10px 0 0; } .right-content p{ padding: 0 20px 0 10px; } .right-fooder{ position: relative; } .fooder-round1{ width:400px; height:400px; border-radius: 200px; position: absolute; top: 1000px; left: -50px; background: rgb(83, 82, 93); } .fooder-round2{ width:700px; height:500px; border-radius: 250px; position: absolute; top: 970px; left: 300px; background: rgb(83, 82, 93); } @media (max-width:900px){ .contain{ width: 700px; margin: auto; } /* left */ .contain-left{ position: relative; width: 160px; height: 1000px; border-radius: 0 500px 500px 0; margin-top: 50px; } .left-header{ position: absolute; top:0px; left: 50px; width: 120px; height: 120px; overflow: hidden; border-radius: 60px; } .left-fooder{ width: 120px; } .left-content1 h3{ margin-left: 20px; } /* contain-right*/ .contain-right{ width: 540px; position: relative; } .right-header{ position: absolute; top:-140px; right: -300px; width: 600px; height: 300px; border-radius:300px; } .right-header-text{ position: absolute; top:130px; right: 360px; color: #fff; } .right-header-text h1{ font-size: 30px; } .right-content{ font-size: 12px; } .right-content h2{ width: 100px; height: 30px; border-radius: 15px; line-height: 30px; } @media (max-width:730px){ .contain{ width: 400px; height: 980px; margin: auto; } /* left */ .contain-left{ float: left; position: relative; width: 100px; height: 980px; border-radius: 0 500px 500px 0; margin-top: 30px; margin-left: -100px; overflow: none; transition: 0.5s; overflow: none; z-index: 1; } .contain-left:hover{ margin-left: 0; z-index: 3; } .left-more{ display: block; cursor: pointer; } .left-more:hover + .contain-left{ margin-left: 0; } .left-header{ position: absolute; top:0px; left: 20px; width: 60px; height: 60px; border-radius: 30px; } .left-fooder{ position: absolute; top:80px; left: 10px; width: 70px; } .left-content1 h3{ width: 60px; margin-left: 14px; margin-top: 16px; font-size: 14px; box-shadow: 2px 2px #b5a9a9; } .left-content1 p{ font-size: 12px; width: 86px; } .left-content2 p{ font-weight: bold; text-align: right; } .left-content2 span{ display: block; margin-top: -8px; text-align: right; font-size: 10px; } .span1{ word-break: break-all; } /* contain-right*/ .contain-right{ float: right; width: 300px; position: relative; } .right-header{ position: absolute; top:-180px; right: -200px; width: 400px; height: 300px; border-radius:200px; } .right-header-text{ position: absolute; top:180px; right: 240px; color: #fff; } .right-header-text h1{ font-size: 24px; text-shadow: 2px 2px #b5a9a9; } .right-header-text p{ margin-left: 16px; line-height: 12px; font-size: 10px; } .right-content{ position: absolute; top:80px; left: 0px; margin-left: -30px; font-size: 10px; } .right-content h2{ width: 80px; height: 20px; margin-top: 20px; border-radius: 10px; line-height: 20px; } .right-content span{ font-weight: bold; padding: 0 6px 0 0; font-size: 10px; } .right-content p{ padding: 0 20px 0 10px; } .right-fooder{ position: relative; } .fooder-round1{ width:300px; height:300px; border-radius: 150px; position: absolute; top: 940px; left: -140px; } .fooder-round2{ width:300px; height:300px; border-radius: 150px; position: absolute; top: 880px; left: 80px; } } 更多信息 个人简历 大二本科在校生，现正就读于广东工业大学，对前端很感兴趣，所以加入本校的一个前端工作室 ，至今已接触前端有七八个月了，熟悉html、css、js基本语法，专攻vue框架，对其它一些流行框架止于知晓理解。 技能证书 计算机二级 中级软件工程师 英语六级 基本信息 出生年月 1999.05.09 联系电话 15521035856 联系邮箱 208781239@qq.com 居住地址 广州市天河区广东工业大学（龙洞校区） 林泽坚 求职意向： 前端工程师 实习经验 2016.09-2017.21 &nbsp|| &nbsp xx公司 &nbsp|| &nbsp 职位 还没开始实习，有待加油！！！ 2016.09-2017.21 &nbsp|| &nbsp xx公司 &nbsp|| &nbsp 职位 占个位置先 个人技能 vue框架 专攻vue框架，通过结合node.js搭建vue脚手架做项目联系，且以此搭建 个人简易网站（） 第二个网站 通过node.js与hexo结合搭建架构，再上传至git实现网络 访问，网站记录学习的进度与心得 数据库设计 Java课程设计--简易员工管理系统，经老师同意，通过对JQ-EasyUI框架的使用、Mysql数据库的 建立连接，运用PHP相关语法进行搭建，实现管理系统的基础操作与数据交互 教育背景 2016.09-至今 &nbsp|| &nbsp 广东工业大学 &nbsp|| &nbsp 信息与计算科学 现正就读于广东工业大学应用数学学院信息与计算科学专业， 主修数学类课程（高等代数，数学分析，数据结构，数值分析，数学建模 概率论与数理统计）与部分编程语言基础（c，c++，Java） 2018大三学年荣获奖学金 努力看看能不能拿一个呀！！ 个人评价 平易近人，乐于交友是我最大的优势；时间感极强，会谨记与提前准备， 从不打无准备的战；勤勤恳恳，对承诺的事积极负责；"},{"title":"","date":"2018-12-20T15:44:02.139Z","updated":"2018-12-20T15:44:02.139Z","comments":true,"path":"js/pdf.js","permalink":"http://github.com/js/pdf.js","excerpt":"","text":"var btn = document.getElementById(\"btn\"); btn.onclick=function(){ alert(\"hello world\"); }"},{"title":"hexo搭建个人博客总结","date":"2018-04-23T08:42:17.000Z","updated":"2018-04-23T08:46:51.377Z","comments":true,"path":"个人资料/index.html","permalink":"http://github.com/个人资料/index.html","excerpt":"","text":"h1h2h3h4h5h6"},{"title":"","date":"2018-12-20T15:46:06.537Z","updated":"2014-10-21T02:42:51.152Z","comments":true,"path":"js/pdfobject.js","permalink":"http://github.com/js/pdfobject.js","excerpt":"","text":"/* PDFObject, copyright (C) 2008 Philip Hutchison (pipwerks.com). Documentation and examples are at www.pdfobject.com. Version 1.2, April 2011. MIT style license */ var PDFObject=function(y){if(!y||!y.url){return false;}var w=\"1.2\",b=y.id||false,i=y.width||\"100%\",z=y.height||\"100%\",r=y.pdfOpenParams,a,x;var v=function(){var c=null;if(window.ActiveXObject){c=new ActiveXObject(\"AcroPDF.PDF\");if(!c){c=new ActiveXObject(\"PDF.PdfCtrl\");}if(c!==null){return true;}}return false;};var u=function(){var c,f=navigator.plugins,d=f.length,e=/Adobe Reader|Adobe PDF|Acrobat/gi;for(c=0;c';return c.getElementsByTagName(\"object\")[0];};a=encodeURI(y.url)+\"#\"+p(r);x=s();this.get=function(c){return o(c);};this.embed=function(c){return n(c);};return this;};"},{"title":"暑假冲凉照集","date":"2018-07-30T15:32:23.000Z","updated":"2018-12-20T08:02:54.997Z","comments":true,"path":"个人资料/暑假照片集（冲凉）.html","permalink":"http://github.com/个人资料/暑假照片集（冲凉）.html","excerpt":"帅哥靓女（luo） 照！嘿嘿嘿！！！（简单版）外人勿进！！！","text":"帅哥靓女（luo） 照！嘿嘿嘿！！！（简单版）外人勿进！！！ 请带上眼镜！！！"},{"title":"暑假照片集","date":"2018-07-30T14:32:23.000Z","updated":"2018-12-20T07:46:17.010Z","comments":true,"path":"个人资料/暑假照片集.html","permalink":"http://github.com/个人资料/暑假照片集.html","excerpt":"帅哥靓女照！嘿嘿嘿！！！（简单版）外人勿进！！！","text":"帅哥靓女照！嘿嘿嘿！！！（简单版）外人勿进！！！ 1. 乡里美图 2. 冲凉照"},{"title":"","date":"2018-12-20T15:59:46.249Z","updated":"2018-05-16T06:59:01.959Z","comments":true,"path":"js/pdfobject/index.html","permalink":"http://github.com/js/pdfobject/index.html","excerpt":"","text":"PDF在线阅读插件PDFObject.js下载 - 多多软件站 window.onload = function (){ var myPDF = new PDFObject({ url: \"sample.pdf\" }).embed(); }; 当您看到这行文字说明您并没有安装 Adobe Reader 或者 PDF 浏览器支持插件 请将PDF文件下载到本地阅读"},{"title":"","date":"2018-12-20T15:59:46.255Z","updated":"2014-10-21T02:42:51.152Z","comments":true,"path":"js/pdfobject/pdfobject.js","permalink":"http://github.com/js/pdfobject/pdfobject.js","excerpt":"","text":"/* PDFObject, copyright (C) 2008 Philip Hutchison (pipwerks.com). Documentation and examples are at www.pdfobject.com. Version 1.2, April 2011. MIT style license */ var PDFObject=function(y){if(!y||!y.url){return false;}var w=\"1.2\",b=y.id||false,i=y.width||\"100%\",z=y.height||\"100%\",r=y.pdfOpenParams,a,x;var v=function(){var c=null;if(window.ActiveXObject){c=new ActiveXObject(\"AcroPDF.PDF\");if(!c){c=new ActiveXObject(\"PDF.PdfCtrl\");}if(c!==null){return true;}}return false;};var u=function(){var c,f=navigator.plugins,d=f.length,e=/Adobe Reader|Adobe PDF|Acrobat/gi;for(c=0;c';return c.getElementsByTagName(\"object\")[0];};a=encodeURI(y.url)+\"#\"+p(r);x=s();this.get=function(c){return o(c);};this.embed=function(c){return n(c);};return this;};"},{"title":"","date":"2018-12-20T15:59:46.253Z","updated":"2014-10-21T02:42:51.152Z","comments":true,"path":"js/pdfobject/js/pdfobject.js","permalink":"http://github.com/js/pdfobject/js/pdfobject.js","excerpt":"","text":"/* PDFObject, copyright (C) 2008 Philip Hutchison (pipwerks.com). Documentation and examples are at www.pdfobject.com. Version 1.2, April 2011. MIT style license */ var PDFObject=function(y){if(!y||!y.url){return false;}var w=\"1.2\",b=y.id||false,i=y.width||\"100%\",z=y.height||\"100%\",r=y.pdfOpenParams,a,x;var v=function(){var c=null;if(window.ActiveXObject){c=new ActiveXObject(\"AcroPDF.PDF\");if(!c){c=new ActiveXObject(\"PDF.PdfCtrl\");}if(c!==null){return true;}}return false;};var u=function(){var c,f=navigator.plugins,d=f.length,e=/Adobe Reader|Adobe PDF|Acrobat/gi;for(c=0;c';return c.getElementsByTagName(\"object\")[0];};a=encodeURI(y.url)+\"#\"+p(r);x=s();this.get=function(c){return o(c);};this.embed=function(c){return n(c);};return this;};"}],"posts":[{"title":"hexo的yilia主题界面的修改","slug":"界面主题的修改","date":"2019-12-04T10:24:23.000Z","updated":"2019-12-05T04:21:50.178Z","comments":true,"path":"2019/12/04/界面主题的修改/","link":"","permalink":"http://github.com/2019/12/04/界面主题的修改/","excerpt":"hexo搭建个人博客结–对hexo的yilia主题界面的修改","text":"hexo搭建个人博客结–对hexo的yilia主题界面的修改 今天看到了一个hexo的相关主题，挺好看的，yelee，是在yilia上改进的 改来改去，结果老是不能达到要求，完全替换主题实现不了，要不就是文章显示不出，但在相对应的地方点击却能点击访问，找不出问题，下次再来玩玩修改 既然想改主题了，就没事改一下背景颜色玩玩 两张图，前后对比，哪个好看？还是都丑了一批，哈哈哈哈,可能就我最喜欢蓝色吧，哈哈哈","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"更新日记","slug":"更新","date":"2019-11-24T04:14:34.000Z","updated":"2019-12-05T04:20:59.389Z","comments":true,"path":"2019/11/24/更新/","link":"","permalink":"http://github.com/2019/11/24/更新/","excerpt":"最近这里都没有更新笔记，因为为了方便，都写在GitHub上了","text":"最近这里都没有更新笔记，因为为了方便，都写在GitHub上了 现在大多数笔记都写在自己的GitHub产库里，方便阅读跟保存地址：https://github.com/yoona-lin/learning-records","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://github.com/tags/笔记/"}]},{"title":"hexo搭建个人博客总结（7）","slug":"hexo搭建博客（七）","date":"2019-09-03T14:32:23.000Z","updated":"2019-12-04T10:24:00.977Z","comments":true,"path":"2019/09/03/hexo搭建博客（七）/","link":"","permalink":"http://github.com/2019/09/03/hexo搭建博客（七）/","excerpt":"hexo搭建个人博客总结–继续补充修改（网站上方导航栏图标）","text":"hexo搭建个人博客总结–继续补充修改（网站上方导航栏图标） 1.网站上方导航栏图标增加网站上方导航栏图标，弄一个好看的图标，因为可以先放在本地yilla主题目录下的img文件里，然后再git上传到github上就行，去下载个图标就行，并且图像为16*16像素，不要超过16色。文件格式为ico，然后上传至你的网站。 形如： icon.ico然后，在需要的页面中，加上以下html语句到文件的和之间（假设以上ico文件的地址为http://www.csdn.net/icon.ico）。 。 本地修改主题目录下的 _config.yml 配置文件的 favicon: /img/Webicon.png favicon 属性即可。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"脑图集","slug":"暑假整理知识点脑图","date":"2019-08-23T13:23:17.000Z","updated":"2019-08-28T12:49:26.172Z","comments":true,"path":"2019/08/23/暑假整理知识点脑图/","link":"","permalink":"http://github.com/2019/08/23/暑假整理知识点脑图/","excerpt":"点击查看更多","text":"点击查看更多 知识点 W3CAjAX+JSON) W3School(Web+Service) W3school（HTML+DOM+与+jQuery） w3school_（TCP、IP与XML） 廖雪峰Git教程 廖雪峰js教程 图片太大了，放在这里显示有问题，全部都放在github上了https://github.com/yoona-lin/Brain-map","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"脑图","slug":"脑图","permalink":"http://github.com/tags/脑图/"}]},{"title":"前端网没了","slug":"前端网总结","date":"2019-08-18T08:42:17.000Z","updated":"2019-08-31T12:23:36.801Z","comments":true,"path":"2019/08/18/前端网总结/","link":"","permalink":"http://github.com/2019/08/18/前端网总结/","excerpt":"没了!!!(前端网没了，待重新整理)","text":"没了!!!(前端网没了，待重新整理) 前端网没了之前为了访问方便，把一些学习心得编辑在前端网上（http://www.qdfuns.com/），结果现在网站没了，内容直接全不见了，之后再找时间整理，重新写。。。。了。。。。","categories":[],"tags":[{"name":"前端网","slug":"前端网","permalink":"http://github.com/tags/前端网/"}]},{"title":"搭建简易实验中心网站模板","slug":"实验中心网站模板","date":"2019-08-18T08:42:17.000Z","updated":"2019-08-28T08:20:38.637Z","comments":true,"path":"2019/08/18/实验中心网站模板/","link":"","permalink":"http://github.com/2019/08/18/实验中心网站模板/","excerpt":"点击查看更多","text":"点击查看更多 暑假做的一个实验中心网站静态模板，自行下载查看效果 git网址:https://github.com/yoona-lin/web-formwork","categories":[],"tags":[{"name":"网站模板","slug":"网站模板","permalink":"http://github.com/tags/网站模板/"}]},{"title":"前端学习路线及资料整理总结","slug":"前端学习总结","date":"2019-05-07T14:20:12.000Z","updated":"2019-08-31T12:24:15.992Z","comments":true,"path":"2019/05/07/前端学习总结/","link":"","permalink":"http://github.com/2019/05/07/前端学习总结/","excerpt":"分享学习路线，希望能帮到你们(前端网没了，待重新整理)","text":"分享学习路线，希望能帮到你们(前端网没了，待重新整理) 前端学习路线及资料整理","categories":[],"tags":[{"name":"学习资料","slug":"学习资料","permalink":"http://github.com/tags/学习资料/"}]},{"title":"前端笔试题(2019/04/28)","slug":"前端笔试题（二）","date":"2019-04-28T08:20:12.000Z","updated":"2019-08-28T12:51:28.672Z","comments":true,"path":"2019/04/28/前端笔试题（二）/","link":"","permalink":"http://github.com/2019/04/28/前端笔试题（二）/","excerpt":"open!(前端网没了，待重新整理)","text":"open!(前端网没了，待重新整理) 前端笔试题(2019/04/28)","categories":[],"tags":[{"name":"笔试题","slug":"笔试题","permalink":"http://github.com/tags/笔试题/"}]},{"title":"小程序（微天气）","slug":"小程序——微天气","date":"2019-04-22T07:34:21.000Z","updated":"2019-05-20T07:25:35.771Z","comments":true,"path":"2019/04/22/小程序——微天气/","link":"","permalink":"http://github.com/2019/04/22/小程序——微天气/","excerpt":"小程序（微天气）","text":"小程序（微天气） 小程序之前看过一些，现在跟着做一个个人注册的天气查询小程序 扫码试试看–&gt; 源码地址下载：git地址","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://github.com/tags/微信小程序/"}]},{"title":"前端笔试题(2019/04/02)","slug":"前端笔试题（一）","date":"2019-04-02T14:45:12.000Z","updated":"2019-08-31T12:23:39.785Z","comments":true,"path":"2019/04/02/前端笔试题（一）/","link":"","permalink":"http://github.com/2019/04/02/前端笔试题（一）/","excerpt":"open!(前端网没了，待重新整理)","text":"open!(前端网没了，待重新整理) 前端笔试题(2019/04/02)","categories":[],"tags":[{"name":"笔试题","slug":"笔试题","permalink":"http://github.com/tags/笔试题/"}]},{"title":"vue小练习集","slug":"vue小练习","date":"2019-03-05T06:23:54.000Z","updated":"2019-09-14T07:30:42.213Z","comments":true,"path":"2019/03/05/vue小练习/","link":"","permalink":"http://github.com/2019/03/05/vue小练习/","excerpt":"vue几个小练习 (前端网没了，已重新整理)","text":"vue几个小练习 (前端网没了，已重新整理) 开发一个数字输出口组件https://www.qdfuns.com/article/49955/3a462816b1cb65edb4c8dc1e71857937.html 开发一个标签页组件https://www.qdfuns.com/article/49955/69428e37887930f0bb1138e054775f93.html 开发一个下拉框简单组件https://www.qdfuns.com/article/49955/7f2ce57d45850dc8c5f8248437a85e9a.html 新的地址github","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://github.com/tags/vue/"},{"name":"项目练习","slug":"项目练习","permalink":"http://github.com/tags/项目练习/"}]},{"title":"vue搭建简单个人天气预报","slug":"vue搭建简单个人天气预报","date":"2019-02-28T15:12:23.000Z","updated":"2019-09-14T07:29:02.303Z","comments":true,"path":"2019/02/28/vue搭建简单个人天气预报/","link":"","permalink":"http://github.com/2019/02/28/vue搭建简单个人天气预报/","excerpt":"vue搭建简单个人天气预报 (前端网没了，已重新整理)","text":"vue搭建简单个人天气预报 (前端网没了，已重新整理) 不能访问因为前端网的文件格式一样，就不重新复制一遍了，点击网址查看详细知识：https://www.qdfuns.com/article/49955/7dbfb5e41bee4ef9a4419c5af642f37c.html 新的地址github","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://github.com/tags/vue/"},{"name":"项目练习","slug":"项目练习","permalink":"http://github.com/tags/项目练习/"}]},{"title":"vue搭建购物车简单练习实例","slug":"Vue简单练习--搭建简单购物车","date":"2019-02-28T14:56:34.000Z","updated":"2019-09-14T07:11:00.522Z","comments":true,"path":"2019/02/28/Vue简单练习--搭建简单购物车/","link":"","permalink":"http://github.com/2019/02/28/Vue简单练习--搭建简单购物车/","excerpt":"vue搭建购物车简单练习实例（静态练习）(前端网没了，已重新整理)","text":"vue搭建购物车简单练习实例（静态练习）(前端网没了，已重新整理)因为前端网的文件格式一样，就不重新复制一遍了，点击网址查看详细知识：https://www.qdfuns.com/article/49955/0959a1b25f092e1eb34ad634160899de.html 新存放地址github","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"http://github.com/tags/小练习/"},{"name":"vue","slug":"vue","permalink":"http://github.com/tags/vue/"}]},{"title":"hexo搭建个人博客总结（6）","slug":"hexo搭建个人博客总结（六）","date":"2018-12-22T16:32:23.000Z","updated":"2019-02-28T14:59:37.431Z","comments":true,"path":"2018/12/23/hexo搭建个人博客总结（六）/","link":"","permalink":"http://github.com/2018/12/23/hexo搭建个人博客总结（六）/","excerpt":"hexo搭建个人博客总结–继续补充加强（valine评论功能）","text":"hexo搭建个人博客总结–继续补充加强（valine评论功能） valine评论功能针对之前测试问题：来必力评论功能加载过慢，很影响体验百度到另一个评论插件valine，更好用一些。速度快。简洁漂亮，功能也不少。在这里先完成相关配置设置，到时再转换评论功能在进行设置 教程 算了，过段时间再弄","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"},{"name":"评论功能","slug":"评论功能","permalink":"http://github.com/tags/评论功能/"}]},{"title":"hexo搭建个人博客总结（5）","slug":"hexo搭建个人博客总结（五）","date":"2018-12-20T16:32:23.000Z","updated":"2019-08-28T07:00:52.159Z","comments":true,"path":"2018/12/21/hexo搭建个人博客总结（五）/","link":"","permalink":"http://github.com/2018/12/21/hexo搭建个人博客总结（五）/","excerpt":"hexo搭建个人博客总结–继续补充加强（统计功能与评论功能）","text":"hexo搭建个人博客总结–继续补充加强（统计功能与评论功能） 百度统计 1.资料 百度统计 yoona-lin Lxxxxxxxxxxxxxxj 155xxxxxxxxx56 相关申请流程百度可知 2.设置编辑文件 themes/yilia/_config.yml ,添加一行配置，可以删除原来的google analytics123456789101112131415baidu_tongji: true / xxxxxxxxxxxxxxxxx新建 `themes/yilia/layout/_partial/baidu_tongji.ejs` 内容如下&lt;% if (theme.baidu_tongji) &#123; %&gt;&lt;script type=\"text/javascript\"&gt;#申请的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt;编辑`themes/yilia/layout/_partial/head.ejs` 在 &lt;/head&gt; 前添加&lt;%- partial(\"baidu_tongji\") %&gt; 重新生产部署站点即可。 nice，安装成功。 来必力注册账号（来必力Yoona-linlxxxxxxxxxxx20xxxxxxxxx@qq.com 打开来必力官网： 来必力 按套路注册（注册挺慢的，要等它页面刷出来，然后接受到一封韩文验证码qq文件，百度翻译阅读，继续安装）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。 安装点击上方的安装，选择免费的city版本。 并点击现在安装，出现如下界面。复制其中的uid字段。 打开主题目录下的 blog/themes/next/_config.yml 配置文件，定位到 livere_uid(没有就直接添加在评论功能附近) 字段。 在hexo\\themes\\yilia\\layout_partial\\post\\下新建一个livere_uid.ejs的文件,将上述代码copy到该文件中 修改hexo\\themes\\yilia\\layout_partial\\article.ejs,找到1&lt;%if (!index &amp;&amp; post.comments)&#123; %&gt; 在下面添加1234567&lt;% if (theme.livere_uid)&#123; %&gt; &lt;%- partial('post/livere_uid', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;% &#125; %&gt; 或者直接把上述代码放在这里 至此，大功告成。效果展示（下拉看看~~~~） 测试问题：来必力评论功能加载过慢，很影响体验百度到另一个评论插件valine，更好用一些。速度快。简洁漂亮，功能也不少。等再测试一阵子再换个看看 。。。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"},{"name":"统计、评论功能","slug":"统计、评论功能","permalink":"http://github.com/tags/统计、评论功能/"}]},{"title":"SQL数据库实验报告","slug":"SQL数据库实验报告","date":"2018-12-20T14:52:26.334Z","updated":"2018-12-20T19:31:15.750Z","comments":true,"path":"2018/12/20/SQL数据库实验报告/","link":"","permalink":"http://github.com/2018/12/20/SQL数据库实验报告/","excerpt":"SQL数据库实验报告","text":"SQL数据库实验报告 more &gt;&gt; 知识点：实现在HTML文件上浏览PDF文件百度可知用到一款jquery插件：PDFObject.js，是一个 JavaScript 库用来在HTML中动态嵌入 PDF 文档。具体的介绍可以百度，这里就这款插件的用法，这款插件操作简单功能强大，只需下载一个PDFObject.js就行了。 12345678910111213141：第一步，网上下载PDFObject.js文件2： &lt;script type=\"text/javascript\" src=\"js/pdfobject.js\"&gt;//js文件夹里&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function ()&#123; var myPDF = new PDFObject(&#123; url: \"sample.pdf\" &#125;).embed(); &#125;; //文件在又一个文件夹下 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;当您看到这行文字说明您并没有安装 Adobe Reader 或者 PDF 浏览器支持插件 &lt;a href=\"sample.pdf\"&gt;请将PDF文件下载到本地阅读&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;","categories":[],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://github.com/tags/实验报告/"}]},{"title":"ASP.NET 与 .NET.Core 相关知识点","slug":"ASP.net相关知识点","date":"2018-10-27T03:17:26.000Z","updated":"2018-10-31T09:23:20.284Z","comments":true,"path":"2018/10/27/ASP.net相关知识点/","link":"","permalink":"http://github.com/2018/10/27/ASP.net相关知识点/","excerpt":"认识ASP.NET 与 ASP.NET,Core","text":"认识ASP.NET 与 ASP.NET,Core 1.ASP.net mvc5和asp.net.core有什么区别呢，前景如何：区别：ASP.NET Core是 ASP.NET 的替代方法。 asp.net mvc5只能运行在Windows，一般通过IIS发布。 ASP.NET 4.x 是一个成熟的框架，提供在 Windows 上生成基于服务器的企业级 Web 应用所需的服务。 asp.net core开源，可跨平台，能够发布到Linux等系统上。asp.net core做了很多的*整合工作，目前来说完成了最基本的一部分类库的迁移。 ASP.NET Core 是一个跨平台的开源框架，用于在 Windows、macOS 或 Linux 上生成基于云的新式 Web 应用。 前景： asp.net core肯定是以后的一种潮流，随着docker等技术的普及，跨平台的重要性凸显，必须要使用asp.net core编写的接口才能发布到linux中，也就是asp.net core编写的接口可以做成docker的镜像发布，而asp.net mvc5不能。所以最终肯定是会慢慢都转移到asp.net core上来。但是这需要一个比较久的过程。因为从asp.net mvc5转移到asp.net core需要一定时间的学习，即使在国外也需要一定过程。而国内由于语言环境、开发工具（需要VS2015才能进行asp.net core的开发）等的原因，肯定需要更久。国内的技术一直以来也比较保守。 如果单纯的以在国内找个开发的工作的话，建议先熟悉下asp.net mvc5。如果确实有跨平台的需求，或者团队成员都对新技术有很高的热情，从事的也是全新的项目的话，就使用asp.net core。 .net core： .NET Core 是.NET Framework的新一代版本，是微软开发的第一个官方版本，具有跨平台 (Windows、Mac OSX、Linux) 能力的应用程序开发框架 (Application Framework)，未来也将会支持 FreeBSD 与 Alpine 平台，也是微软在一开始发展时就开源的软件平台[1] ，它经常也会拿来和现有的开源 .NET 平台 Mono 比较。 由于 .NET Core 的开发目标是跨平台的 .NET 平台，因此 .NET Core 会包含 .NET Framework 的类库，但与 .NET Framework 不同的是 .NET Core 采用包化 (Packages) 的管理方式，应用程序只需要获取需要的组件即可，与 .NET Framework 大包式安装的作法截然不同，同时各包亦有独立的版本线 (Version line)，不再硬性要求应用程序跟随主线版本。 在 ASP.NET 4.x 和 ASP.NET Core 之间进行选择 2.视频资源网易云课堂—-ASP.NET快速入门 视频讲解挺不错的，可听听！！！ 3.ASP.NET相关介绍一.认识ASP.NET一些基本的文件和文件夹 1.普通文件夹常规语义化命名文件，放置相对应功能的文件(文件引入直接拉取放入，编辑器会自动添加，如css，js) 2.VS环境赋予了特殊含义的文件夹 App_Code：用来存放一些网站中用到的类文件 App_Data：用来存放数据库文件 Bin：用来存放网站需要的引用 .dll文件 3.常见后缀名的文件 .aspx 这个用来写网站布局的文件 网站的前后台代码（html，css，js，.net控件。。。） .aspx.cs 用来写网站的后台代码文件，其实相当于类文件 网站的后台代码（C#代码。。。） 4.用户自定义控件 .ascx 网站前台代码 (点击“拆分”双击对于按钮即可调到对应后台代码区) .ascx.cs 网站的后台代码 5.web.config 这个文件是网站的配置文件，新建网站的时候系统会帮我们自动生成 ——– xml语言 ————网站大管家 二.了解ASP.NET控件与html标签关系.net自带的一些控件可以方便我们程序的书写，但是最终会被浏览器翻译成html代码，也就是说 .net控件最终呈现的形式还是html代码（控件的引入在“工具箱”内，直接点击调用即可） 三.前后台代码之间的联系Button按钮事件各类事件触发(点击“拆分”双击对于按钮即可调到对应后台代码区) 四. ASP.NET网站开发的两种模式 1.上面所说的前后台代码模式2.三层架构模式(深入知识点) 数据访问层 dao 业户逻辑层 service 用户表现层 web 4.QueryString 认识字面意思就是查询字符串 http://www.aaabbb.com?name=zs&amp;pwd=123 介绍QueryString的创建与使用 （1）创建就是放在一个网址后面？变量名=变量值？变量名1=变量值1&amp;变量名2=变量值2&amp;.... (2)使用Request.QueryString[“id”] //得到 1Request.QueryString[“cc”] //得到 liliRequest.QueryString[“aaaa”] //得到null，找不到 用途：在做删除和修改的时候，非常有用，跟在网址后面 5. Session 的创建与使用概念：Session即会话，是指一个用户在一段时间内对某一个站点的一次访问。（1）创建：Session[“变量名”]=值’；Session.add(“变量名”，值)； Session[“username”]=”zs”;等同于 Session.Add(“username”,”zs”); (2)使用Session[“变量名”]就可以了Session[‘username’] 这就是代表“zs”这个字符串 （3）移出Session.RemoveAll() 或者 Session.Clear()一般情况下Session的有效时间为20分钟Session.Timeout=…; 常用于的场景： 登录 2.Coolie概念：有时也用其复数形式Coolies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的密码： 1周， 1个月， 1年 （1）创建HttpCookie cookie = new HttpCookie[“aspcn”];cookie.Value = “aaa”;Response.AppendCookie(cookie); //写到本地浏览器 cookie.Value.Add(“webmaster”,”aaa”);cookie.Value.Add(“writer”,”beige”);cookie.Value.Add(“LinkColor”,”blue”);Response.AppendCookie(cookie); (2)使用HttpCookie cookie = Request.Cookies[“aspcn”]; //Request对象取cookie的值value1 = cookie.Value[“webmaster”];value2 = cookie.Value[“writer”]; HttpCookie cookie = Request.cookie[strkey];if(null == cookie){ //cookie不存在} ///","categories":[],"tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://github.com/tags/ASP-NET/"},{"name":".NET.Core","slug":"NET-Core","permalink":"http://github.com/tags/NET-Core/"}]},{"title":"JavaScript小练习(4)","slug":"JavaScript小练习（4）","date":"2018-10-25T12:16:34.000Z","updated":"2018-10-31T10:15:28.961Z","comments":true,"path":"2018/10/25/JavaScript小练习（4）/","link":"","permalink":"http://github.com/2018/10/25/JavaScript小练习（4）/","excerpt":"JavaScript、html、css 小练习与知识点","text":"JavaScript、html、css 小练习与知识点 1.123456789101112下面代码输出什么内容：function makeNoSense(x)&#123; this.x = x;&#125;makeNoSense(5); // 5 x已经是一个=值为5的全局变量console.log(x);function test()&#123; this.x = 1; alert(this.x);&#125;test();// 1这是函数的最通常用法，属于全局性调用，因此this就代表全局变量Clobal；函数也可以被调用，此时this绑定到全局对象。 21234567891011121314function Point(x,y)&#123; this.x = x; this.y = y; this.moveTo = function(x,y)&#123; this.x = x; this.y = y; console.log(this.x+\",\"+this.y); &#125;&#125;var p1 = new Point(0,0);var p2 = &#123;x: 0, y: 0&#125;;p1.moveTo(1,1);//1,1p1.moveTo.apple(p2,[10,10]);//10,10在上面的例子中，我们使用构造函数生成一个对象p1，该对象同时具有moveTo方法；使用对象字面量创建另一个对象p2，我们看到使用apple方法可以将p1的方法应用到p2上，这时的this也绑定到对象p2上，指向p2；另一个方法call也具备同样的功能，不同的是最后的参数不是作为数组统一传入，而是分开传入的。 3.123456789101112下面代码输出什么内容？(function()&#123; var a=b=3;&#125;)();console.log(\"a defined?\" + (typeof a!=='undefined'));console.log(\"b defined?\" + (typeof b!=='undefined'));这里的问题是大多数开发人员错误理解语句 var a=b=3 为：var b=3；var b=3；但实际上 var a=b=3 为： b=3；var a=b；因此（如果你不使用严格模式），代码片段的输出将为：a defined？false；b defined？true；注意：如果在严格模式下（即使用 strict），语句 var a=b=3 会产生一个ReferenceError的运行时错误：b没有定义，从而避免了可能导致任何头head-fakes/bugs。（这就是为什么你应该在你的代码中使用strict，一个重要的例子） 4.写一个sum方法，当使用下面的语法调用时它将正常工作：1234567891011121314151617181920212223242526console.log(sum(2,3)); //Outputs 5console.log(sum(2)(3)); //Outputs 5有至少两种方法可以做到这一点：方法一：function sum(x)&#123; if(arguments.lenght == 2)&#123; return arguments[0] + arguments[1]; &#125;else &#123; return function(y)&#123; return x + y; &#125;; &#125;&#125;在JavaScript中，函数提供对参数对象的访问，该对象提供对传递给函数的实际参数的访问，这使我们能够使用lenght属性在运行时确定传递给函数的参数数量：如果传递两个参数，那我们就直接相加并返回；否则，我们假设它是以sun(2)(3)的形式被调用的，所以我们返回一个匿名函数，它将传递给sun（）（本例中为2）的参数和传递给匿名函数的参数方法二：function sum(x,y)&#123; if(y !== undefined)&#123; return x + y; &#125;else&#123; return function(y)&#123;return x + y;&#125;; &#125;&#125;当函数被调用，JavaScript不需要参数的数量来匹配函数定义中的参数数量，如果传递的参数数量超过了函数定义中的参数数量，则超出的参数将被忽略；另一方面，如果传递的参数少于定于中的参数数量，则在函数内引用时，缺少是参数将具有未定义的值；因此在上面的例子，通过简单地检查第二个参数是否未定义，我们可以确定函数被调用的方式并相应继续。 。。。","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"http://github.com/tags/小练习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"}]},{"title":"1024程序员节日日记","slug":"1024程序员节日日记","date":"2018-10-24T07:46:36.000Z","updated":"2018-12-20T09:27:31.898Z","comments":true,"path":"2018/10/24/1024程序员节日日记/","link":"","permalink":"http://github.com/2018/10/24/1024程序员节日日记/","excerpt":"时隔多日，再次购买了些技术书籍！！！","text":"时隔多日，再次购买了些技术书籍！！！ 加油！正如那句俗话：1书不买就绝不会有机会看，但屯着了，就有会去看的机会与时候； 那要好好看，好好做笔记，好好写笔记咯！！！ 书籍课程必学知识书籍：12345* Java简明教程* c++面向对象程序设计* 数据结构* 数据库系统原理及应用教程* 计算机网络（第六版） 之前买的： 1234* HTML5 移动Web开发实战详解* 精通css* JavaScript DOM 编程艺术* HTML、css、JavaScript网页制作从入门到精通 这次买的：12345* Vue.js 实战* ASP.NET Core 跨平台开发从入门到实战* 微信小程序* 代码整洁之道* SQL 必知必会 1好好看完！！！","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://github.com/tags/日记/"}]},{"title":"JavaScript小练习(3)","slug":"JavaScript小练习（3）","date":"2018-10-13T03:31:45.000Z","updated":"2018-10-15T15:53:34.666Z","comments":true,"path":"2018/10/13/JavaScript小练习（3）/","link":"","permalink":"http://github.com/2018/10/13/JavaScript小练习（3）/","excerpt":"JavaScript、html、css 小练习与知识点","text":"JavaScript、html、css 小练习与知识点 利用html + css 相关知识，绘制Opera的Logo图标1234567891011121314151617181920212223242526272829&lt;div class=\"opera\"&gt; &lt;div class=\"opera-top\"&gt;&lt;!-- 两层图层，圆角设置成椭圆，再绝对位置覆盖 --&gt; &lt;/div&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .opera&#123; width: 258px; height: 275px; background: #F22629; border-radius: 258px 258px 258px 258px/275px 275px 275px 275px; position:relative; &#125; .opera-top&#123; width: 112px; height: 231px; background: #fff; border-radius: 112px 112px 112px 112px/231px 231px 231px 231px; /* border-radius的含义是：圆角。border-radius是一种缩写方法。如果“/”前后的值都存在，那么“/”前面的值设置其水平半径，“/”后面值设置其垂直半径。 本来只弄前面的话会变成圆；所以当同时设置时就变成椭圆了 */ position: absolute; left: 50%; top: 50%; bottom: 50%; margin-left: -56px; margin-top: -115px; &#125;&lt;/style&gt; 利用css绘制圆弧、圆饼图1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=\"round\"&gt; &lt;div class=\"radius\"&gt;&lt;/div&gt; &lt;p class=\"radius-text\"&gt;如果想添加文字也行&lt;/p&gt; &lt;!-- 绝对定位添加文字解析 --&gt;&lt;/div&gt;&lt;style media=\"screen\"&gt; .round&#123; width: 300px; height: 300px; background: #fff; border-radius: 300px 300px 300px 300px; position:relative; &#125; .radius&#123; width: 0px; height: 0px; background: rgb(84, 77, 75); border-radius: 300px 300px 300px 300px; border: 150px solid; /* 三角形的绘制原理+圆角切割 */ border-color: red transparent transparent transparent ; /* 透明化其它不需要的三角区域 */ position:absolute; left: 50%; top: 50%; z-index: 1; margin-left: -150px; margin-top: -150px; &#125; .radius-text&#123; font-size: 12px; position: absolute; left: 32%; top:60%; z-index: 2; &#125;&lt;/style&gt; 利用css话简单饼图：1234567891011121314151617181920212223242526&lt;div class=\"pie\"&gt;&lt;/div&gt;.pie&#123; width: 140px; height: 140px; background: #8BC34A; border-radius: 50%; background-image: linear-gradient(to right,transparent 50%, #655 0); /* CSS3中Gradient中的两个属性一个， 这两个属性分别为linear-gradient（线性渐变）和radial-gradient（径性渐变）; background: linear-gradient(#fb3 20%, #58a 80%); 将会出现过渡的效果，#fb3开始渐变的位置是20%，在20%之前就只有#fb3，到80%就是#58a */&#125;.pie::before&#123; /* 思路：基于 transform 的解决方案，通过一个rotate()变形属性来使这个伪元素转起来 */ content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; transform: rotate(.1turn);/*10%*/ transform: rotate(.2turn);/*20%*/ transform: rotate(.3turn);/*30%*/&#125; 用css动画来实现一个饼图从0变化到100%的动画，从而得到一个酷炫的进度指示器。123456789101112131415161718192021222324252627&lt;div class=\"pie\"&gt;&lt;/div&gt;.pie&#123; width: 140px; height: 140px; background: yellowgreen; border-radius: 50%; background-image: linear-gradient(to right,transparent 50%, currentColor 0); color: #655;&#125;.pie::before&#123; content: ''; display: block; margin-left: 50%; height: 100%; border-radius: 0 100% 100% 0 / 50%; background-color: inherit; transform-origin: left; -webkit-animation: spin 3s linear infinite, bg 6s step-end infinite;&#125;@@keyframes spin &#123; to&#123;-webkit-transform: rotate(.5turn);&#125;&#125;@@keyframes bg &#123; 50%&#123;background: currentColor;&#125;&#125;// 代码好像有点问题 OVO css做一个漂亮的立体按钮12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;div class=\"box\"&gt; &lt;div class=\"form-actions\"&gt; &lt;button type=\"button\" class=\"btn\"&gt;Click Me&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;.box&#123;width: 550px;text-align: center;line-height: 46px;margin:40px auto;&#125;.btn&#123;position: relative;font-weight:bold;width: 124px;height: 44px;border-radius: 3px;border: 1px solid #c0c0c0;margin:0 50px 40px 0;&#125;.btn:nth-child(1)&#123;color: #848484;border-color: #cecece;box-shadow:inset 0 1px 0 #ececec,0 1px 0 rgba(0,0,0,.2);background:-webkit-linear-gradient(top,#e5e5e5,#d5d5d5);background:-moz-linear-gradient(top,#e5e5e5,#d5d5d5);background:-o-linear-gradient(top,#e5e5e5,#d5d5d5);background:-ms-linear-gradient(top,#e5e5e5,#d5d5d5);background:linear-gradient(top,#e5e5e5,#d5d5d5);&#125;/* 兼容各种浏览器 */.btn:nth-child(1):hover&#123;background:-webkit-linear-gradient(top,#f0f0f0,#dedddd);background:-moz-linear-gradient(top,#f0f0f0,#dedddd);background:-o-linear-gradient(top,#f0f0f0,#dedddd);background:-ms-linear-gradient(top,#f0f0f0,#dedddd);background:linear-gradient(top,#f0f0f0,#dedddd);&#125;.btn:nth-child(1):active&#123;top:4px;box-shadow:inset 0 1px 3px #acacac;background:-webkit-linear-gradient(top,#c6c6c6,#c6c6c6);background:-moz-linear-gradient(top,#c6c6c6,#c6c6c6);background:-o-linear-gradient(top,#c6c6c6,#c6c6c6);background:-ms-linear-gradient(top,#c6c6c6,#c6c6c6);background:linear-gradient(top,#c6c6c6,#c6c6c6);&#125;.btn:before,.btn:after&#123;position: absolute;content: \"\";height: 50%;border-radius: 50%;z-index: -1;&#125;.btn:before &#123;/* 上阴影 */width: 90%;left: 5%;top:12%;box-shadow: 0 -7px 4px rgba(0,0,0,0.3);&#125;.btn:after &#123;/* 下阴影 */width: 80%;left: 10%;bottom: 9%;box-shadow: 0 7px 4px rgba(0,0,0,0.4);&#125; 。。。","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"http://github.com/tags/小练习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"http://github.com/tags/html/"}]},{"title":"ASP.NET搭建图书管理系统系统总结","slug":"ASP搭建图书图书管理系统总结","date":"2018-10-10T15:03:21.000Z","updated":"2018-10-14T15:53:03.377Z","comments":true,"path":"2018/10/10/ASP搭建图书图书管理系统总结/","link":"","permalink":"http://github.com/2018/10/10/ASP搭建图书图书管理系统总结/","excerpt":"源于数据结构课程设计需要，使用ASP来搭建图书管理系统系统，作为课程设计论文内容","text":"源于数据结构课程设计需要，使用ASP来搭建图书管理系统系统，作为课程设计论文内容 1.背景大三数据结构课程设计需要，要做一个图书管理系统的搭建与设计，所以为了贴近前端，为此选择ASP.NET 技术为基础来搭建，现在来回顾总结并详细学习ASP知识点，进一步学习前端相关知识点。 2.ASP.NET 技术 经典的 ASP - Active Server PagesActive Server Pages (ASP)，也被称为经典 ASP（Classic ASP），是由微软于 1998 年发布的第一款服务器端脚本引擎。ASP 是一种令网页中的脚本在 Internet 服务器执行的技术。ASP 页面的文件扩展名是 .asp，通常由 VBScript 编写。 ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。ASP.NET 页面需要编译，因此比经典 ASP 更快。ASP.NET 拥有更好的语言支持，大量用户控件，基于 XML 的组件，以及对用户认证的整合。ASP.NET 页面的扩展名是 .aspx，通常由 VB (Visual Basic) 或 C# (C sharp) 编写。ASP.NET 中的用户控件可以通过不同的语言进行编写，包括 C++ 和 Java。当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 ASP.NET 是一个开放框架，用于通过 HTML、CSS、JavaScript 以及服务器脚本来构建网页和网站。ASP.NET 支持三种开放模式：Web Pages、MVC (Model View Controller) 以及 Web Forms。 详细看W3school教程 内容有点多，要慢慢学了 3.Web Pages 什么是 Web Pages？Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。其他两种编程模型是 Web Forms 和 MVC (Model, View, Controller)。Web Pages 是最简单的 ASP.NET 网页开发编程模型。它提供了一种简单的方法将 HTML、CSS、JavaScript 以及服务器代码结合起来：易于学习、阅读和使用围绕单一网页进行构建类似 PHP 和 ASP服务器脚本使用 Visual Basic 或 C#对 HTML、CSS、JavaScript 的完全控制Web Pages 通过可编程的 Web Helpers 进行扩展，包括数据库、视频、图像、社交网络等等。实例： 123456&lt;html&gt;&lt;body&gt; &lt;h1&gt;Hello Web Pages&lt;/h1&gt; &lt;p&gt;The time is @DateTime.Now&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 什么是 Razor？Razor 是一种向网页添加基于服务器的代码的标记语法Razor 是一种类似 ASP 和 PHP 的服务器端标记语法Razor 代码块由 @{ … } 包围行内表达式（变量和函数）以 @ 开始代码语句以分号结束变量通过 var 关键词进行声明字符串用引用来包围C# 文件的扩展名是 .cshtml ASP.NET Web Pages - 页面布局通过 Web Pages，您可以使用 @RenderPage() 方法从不同的文件导入内容。布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。每个内容页必须以 Layout 指令开头。 ASP.NET Web Pages - 文件夹“Account” 文件夹包含登录和安全文件“App_Data” 文件包含数据库和数据文件“Images” 文件夹包含图片“Scripts” 文件夹包含浏览器脚本“Shared” 文件夹包含通用文件（比如布局和样式文件）注意URL 和路径的吧表达方式 ASP.NET Web Pages - 全局页面文件的启动顺序当请求到来时，ASP.NET 检查_AppStart 是否存在。如果存在，并且这是对站点的第一次请求，则运行 _AppStart。然后 ASP.NET 检查_PageStart 是否存在。如果存在，则运行 _PageStart，在被请求的页面之前。如果您在 _PageStart 内部引用了对 RunPage() 的调用，那么您可以规定在何处运行被请求的页面。否则，_PageStart 在被请求页面之前运行。 (2018/10/11)(整理过于详细，不需要，接下来要简化做笔记，看快一点) 。。。","categories":[],"tags":[{"name":"ASP","slug":"ASP","permalink":"http://github.com/tags/ASP/"},{"name":"图书管理系统系统","slug":"图书管理系统系统","permalink":"http://github.com/tags/图书管理系统系统/"}]},{"title":"JavaScript小练习(2)","slug":"JavaScript小练习（2）","date":"2018-10-08T14:29:21.000Z","updated":"2018-10-15T16:43:27.471Z","comments":true,"path":"2018/10/08/JavaScript小练习（2）/","link":"","permalink":"http://github.com/2018/10/08/JavaScript小练习（2）/","excerpt":"JavaScript小练习与知识点","text":"JavaScript小练习与知识点 1.小练习—-每天进步一点点求数组最小值：Math.min.apple(null,arr)123456789101112131415161718192021222324252627function myMin()&#123; if (argument.length == 0)return Infinity; var arr = [];//作为拷贝数组 for(var i = 0; i &lt; argument.length; i++)&#123; //null相当于0进行比较 if(arguments[i] === null) arr.push(0); //不为空则将内容存入拷贝数组 else arr.push(argument[i]); //查看最后插入的的数组是否为非数 if(isNaN(arr[i])) return NaN; //isNaN()的参数为空数组或只有一个数据的数组时，结果为false，所以要对空数组和只有一个值的数组进行单独判断 var temp = arr[i][0]; while(temp instanceof Array)&#123; //去掉多重数组嵌套的情况 temp = temp[0]; &#125; if(temp=undefined) temp = 0;//嵌套内部可以是undefined if(isNaN(temp)) return NaN;//嵌套内部不能为除undefined外的非数 arr[i] = temp;//将解除嵌套内部的内容添加到数组 &#125; //筛选过程 var result = arr ? arr[0] : 0; for(var i = 0; i&lt; arr.length; i++)&#123; result = arr[i] = result &gt; 0 ? result : arr[i];//将最小的赋值给result &#125; return result;&#125; 如何实现数组的反转（非recover（））1234567891011121314151617181920212223方法一：var arr = [1,2,3,4];var arr2 = [];while (arr, length)&#123; var num = arr.pop(); // 删除数组最后一个元素并返回别删除的元素 arr2.push(num);&#125;console.log(arr2); //[4,3,2,1]方法二：var arr = [1,2,3,4];var arr2 = [];while(arr, length)&#123; var num = arr.shift();//删除数组第一个元素并返回被删除的元素 arr2.unshift(num);&#125;console.log(arr2);//[4,3,2,1]方法三：//recover() 将数组中的元素逆序输出var arr = [1,2,3,4];arr = arr.recover().join();console.log(arr);//[4,3,2,1] join()将数组中所有元素都转化为字符串并连接在一起。1234567891011输入： 分隔符，默认为逗号输出：分隔符分割的字符串//join()不传参，默认用逗号拼接var arr = [1,2,3];var arr2 = [1,2,3];arr = arr.join();console.log(arr); //1,2,3arr2 = arr2.joim(\";\");console.log(arr2); //1;2;3 sort()123456789101112131415比较函数或null。null时表示按照字母表顺序排序；传入带两个参数的比较函数时；第一个参数在前，则返回小于0的数值；第一个参数在后，则返回大于0的数组 // sort() 数组排序 默认按第一个字符排序 var arr = [1,3,52,43,734,66,21]; arr = arr.sort(); console.log(arr); //[1,21,3,43,5,66,734] //按数组值大小排序 从小到大 arr = arr.sort(function(a,b)&#123; return a-b; &#125;); console.log(arr); //[1,3,21,43,52,66,734] //按数组值大小排序 大到小 arr = arr.sort(function(a,b)&#123; return b-a; &#125;); console.log(arr); //[734,66,52,43,3,1] concat() 数组拼接的功能12345// concat() 数组拼接 如果参数中有数组，则连接的是数组元素，而非数组本身；但是不支持递归，不修改调用的数组var arr = [1,3,5,8,9];console.log(arr.concat(4,7)); // [1, 3, 5, 8, 9, 4, 7]console.log(arr.concat([2,0])); // [1, 3, 5, 8, 9, 2, 0]console.log(arr.concat(2,[7,[0,4]])); // [1, 3, 5, 8, 9, 2, 7, [0,4]] splice() 从数组中删除元素、插入元素到数组中或者同时完成这两种操作。12345678// splice() 删除或插入数组元素 第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。如果只有一个参数默认删除后面所有的。返回删除后的数组。var arr = [3,2,6,5,9];console.log(arr.splice(1,3)); // [2,6,5]console.log(arr); // [3,9]console.log(arr.splice(1)); // [2,6,5,9]console.log(arr); // [3]console.log(arr.splice(2,0,'a','b')); // 3个参数表示添加元素， [] 返回删除元素的数组console.log(arr); //[3, 2, \"a\", \"b\", 6, 5, 9] 将a,b添加到数组中 unshift()和shift1234567// shift() 在数组开始添加一个或多个元素，并返回新数组长度2 // unshift() 在数组开始删除一个元素(删且只删除1个),并返回 被删除的元素3 var arr = [8,3,5,6];4 console.log(arr.unshift(9,2)); // 65 console.log(arr); //[9, 2, 8, 3, 5, 6]6 console.log(arr.shift()); //97 console.log(arr); // [2, 8, 3, 5, 6] push()和pop()12345671 // push() 在数组末尾添加一个或多个元素，并返回新数组长度2 // pop() 从数组末尾删除1个元素(删且只删除1个), 并返回 被删除的元素3 var arr = [2,4,9];4 console.log(arr.push(5,3)); // 55 console.log(arr); // [2, 4, 9, 5, 3]6 console.log(arr.pop()); // 37 console.log(arr); // [2, 4, 9, 5] forEach()从头至尾遍历数组，为每个元素调用指定函数1234561 // forEach() 函数的参数依次为：数组元素、元素的索引、数组本身, 无返回2 var arr = [1,2,3,4,5];3 arr.forEach(function(v , i , arr)&#123;4 arr[i] = v+1;5 &#125;);6 console.log(arr); // [2, 3, 4, 5, 6] 更多资料看js数组常用方法总结 数组去重","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"http://github.com/tags/小练习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"}]},{"title":"JavaScript小练习(1)","slug":"JavaScript小练习","date":"2018-10-06T05:53:43.000Z","updated":"2018-10-09T16:21:37.487Z","comments":true,"path":"2018/10/06/JavaScript小练习/","link":"","permalink":"http://github.com/2018/10/06/JavaScript小练习/","excerpt":"JavaScript小练习与知识点","text":"JavaScript小练习与知识点 怎样添加、移除、移动、查找、创建和查找节点？123456789101112131）创建新节点creatDocumentFragment() //创建一个DOM片段creatElement() //创建一个具体的元素creatTextNode () // 创建一个文本节点2) 添加、移除、替换、插入appendChild() // 添加removeChild() // 移除replaceChild() //替换insertBefore() //插入3)查找getElementByTagName() // 通过标签名称 数组查找getElementByTagName()[]getElementByName() // 通过元素的name属性的值 数组查找getElementByName()[]getElemrntById() // 通过元素Id，唯一性 如何从外部读取局部变量123456789101112131415161718192021先给个函数function f1()&#123; var n = 1; function f2()&#123; alert(n) // 1 &#125;&#125;在上面代码中，函数f2就包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。反过来就不行了，f2内部的局部变量，对f1来说就是不可见的，这就是JavaScript语言特有的“链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部访问读取他的内部变量了。function f1()&#123; var n = 1; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 1 怎样将变量的值始终保持在内存当中（闭包）？12345678910111213141516function f1() &#123; var n = 1; nAdd = function()&#123;n+=1;&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result = f1();result(); // 1nAdd();result(); // 2在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是1，第二次的值是2.这就证明了，f1函数中的局部变量n一直保存在内存中，并没有在f1调用后被主动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋予给一个全局变量，这就导致f2始终在内存中，而f2的存在依赖于f1，一次f1也始终在内存中，不会在被调用后被垃圾机制（garbage collection）回收。这一段代码中还有一个要特别注意的地方，就是`“nAdd=function()&#123;n+=1&#125;”`这一行，首先在nAdd前没有用var关键字声明，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个你们还是`（anonymous function）`，而这个匿名函数本身也是一个闭包，所以nAdd相当于一个setter，可以在函数外部对函数内部的局部变量进行操作。","categories":[],"tags":[{"name":"小练习","slug":"小练习","permalink":"http://github.com/tags/小练习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"}]},{"title":"JavaScript知识导图","slug":"JavaScript知识导图","date":"2018-10-03T09:23:17.000Z","updated":"2019-08-28T12:54:36.456Z","comments":true,"path":"2018/10/03/JavaScript知识导图/","link":"","permalink":"http://github.com/2018/10/03/JavaScript知识导图/","excerpt":"知识点图片导图 (前端网没了，待重新整理)","text":"知识点图片导图 (前端网没了，待重新整理)之前放图片的链接失效了，所以把图片放前端网上了；欢迎点击查看：https://www.qdfuns.com/article/49955/56a6e1b2126e132b50596e141daa2302.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"},{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"日记","slug":"2018九月份","date":"2018-10-01T13:42:43.000Z","updated":"2018-10-09T16:28:34.638Z","comments":true,"path":"2018/10/01/2018九月份/","link":"","permalink":"http://github.com/2018/10/01/2018九月份/","excerpt":"九月份","text":"九月份 九月份 九月份开学季，事情挺多的，忙这忙那，虽然断断续续的看了一些，但没好好整理，十月份在继续加油吧！！","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://github.com/tags/日记/"}]},{"title":"人工智能了解","slug":"人工智能学习笔记","date":"2018-08-31T08:22:19.000Z","updated":"2018-09-03T03:44:49.185Z","comments":true,"path":"2018/08/31/人工智能学习笔记/","link":"","permalink":"http://github.com/2018/08/31/人工智能学习笔记/","excerpt":"基础知识点整理、学习","text":"基础知识点整理、学习 1. 简介 AI(Artificial interlligence),即人工智能。人工智能领域的研究包括机器人、语音识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。 2. 关于人工智能，机器学习，神经网络，深度学习 人工智能 人工智能应当归纳成了“逻辑/算法编程”，也就是通过编程将人类所知的知识和逻辑告诉机器，从而借助机器的高速计算和海量存储等能力实现一些人类才能做的“弱智能”工作，我理解上个世纪的深蓝计算机应该就是属于这一类的吧，就是将国际象棋中所有可能的结果都通过预先编好的程序计算出来从而选择最佳的下法(穷举法)。从程序的实现上来说恐怕就是无数的if…else…吧。 而另一类就是基于数据的自我学习，即机器学习，把大量的数据告诉机器由机器自己去分析这些数据从而总结得出某种规律/逻辑，然后利用这种逻辑来处理新的数据。 机器学习 不用写专门的业务逻辑代码而是通过输入大量的数据给机器，由机器通过一个通用的机制来建立它自己的业务逻辑，也就是机器“自我学习”了业务的逻辑，当然这种学习后的逻辑可以用来处理新的数据。这和人类的学习过程有些类似； 机器学习是不断的训练过程，其模型是在连续的优化调整中，随着训练数据越多其模型越准确； 机器学习是通过大量的数据来训练得到模型的，因此其模型考虑的是相关性逻辑，而不是因果性逻辑，这和大数据分析的概念是一致的。 ok，总结起来说，机器学习就是”利用已有数据，得出某种模型，并利用此模型预测未来的方法“。 有监督学习与无监督学习 有监督学习就是训练用历史数据是既有问题又有答案；有监督学习，可以根据预测变量的类型再细分。如果预测变量是连续的，那这就属于回归问题。而如果预测变量是独立类别（定性或是定类的离散值），那这就属于分类问题了。因此有监督学习主要的分类包含： 回归算法 (线性回归，最小二乘回归，LOESS局部回归，神经网路，深度学习） 分类算法（决策树，支持向量机，贝叶斯，K-近邻算法，逻辑回归，随机森林） 无监督学习就是训练用历史数据是只有问题没有答案。在无监督学习中，主要是发现数据中未知的结构或者是趋势。虽然原数据不含任何的标签，但我们希望可以对数据进行整合（分组或者聚类），或是简化数据（降维、移除不必要的变量或者检测异常值）。因此无监督算法主要的分类包含： 聚类算法 (代表：K均值聚类，系统聚类) 降维算法 （代表：主成份分析PCA，线性判断分析LDA） 还有一种介于两者之间的混合学习方法，称为半监督学习 神经网络神经网络是一门重要的机器学习技术。它是目前最为火热的研究方向–深度学习的基础。学习神经网络不仅可以让你掌握一门强大的机器学习方法，同时也可以更好地帮助你理解深度学习技术。神经网络是一种模拟人脑的神经网络以期能够实现类人工智能的机器学习技术。人脑中的神经网络是一个非常复杂的组织。成人的大脑中估计有1000亿个神经元之多。更多知识了解：从神经元到深度学习 。。。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"人工智能","slug":"人工智能","permalink":"http://github.com/tags/人工智能/"}]},{"title":"区块链基础知识","slug":"区块链基础知识学习笔记","date":"2018-08-20T14:42:17.000Z","updated":"2018-09-01T07:04:12.363Z","comments":true,"path":"2018/08/20/区块链基础知识学习笔记/","link":"","permalink":"http://github.com/2018/08/20/区块链基础知识学习笔记/","excerpt":"知识点整理","text":"知识点整理 1. 概念 区块链是一个分布在全球各地、能够协同运转的数据库存储系统，区别于传统数据库运作——读写权限掌握在一个公司或者一个集权手上（中心化的特征），区块链认为，任何有能力架设服务器的人都可以参与其中。来自全球各地的掘金者在当地部署了自己的服务器，并连接到区块链网络中，成为这个分布式数据库存储系统中的一个节点；一旦加入，该节点享有同其他所有节点完全一样的权利与义务（去中心化、分布式的特征）。与此同时，对于在区块链上开展服务的人，可以往这个系统中的任意的节点进行读写操作，最后全世界所有节点会根据某种机制的完成一次又依次的同步，从而实现在区块链网络中所有节点的数据完全一致。 即把多笔交易的信息以及表明该区块的信息打包放在一起，经验证后的这个包就是区块。每个区块里保存了上一个区块的hash值，使区块之间产生关系，也就是说的链了。合起来就叫区块链。 2. 去中心化与分布化 区块链是一个去中心化的系统，确实，「去中心化」在区块链世界里面是一个很重要的概念，很多模型（比如账本的维护、货币的发行、时间戳的设计、网络的维护、节点间的竞争等等等等） 中心化最大的弊端——过分依赖中心和权威，也就意味着逐渐丧失自己的话语权 分布式存储，通过多地备份，制造数据冗余 让所有人都有能力都去维护共同一份数据库 让所有人都有能力彼此监督维护数据库的行为 分布式部署肯定是构建去中心化网络理所当然的解决方向——通过 P2P 协议将全世界所有节点计算机彼此相互连接，形成一张密密麻麻的网络；以巧妙的机制，通过节点之间的交易数据同步来保证全球计算机节点的数据共享和一致。 传统的分布式存储是一个中心化的机构在很多地方做了数据备份，在区块链里是通过链中的各个节点开放的存储空间来建立整个区块链里的分布式数据库 两节点直接进行通讯，不需要经过第三方，保证用户的隐私。 3. 挖矿 去看相对应的文档解释，难以总结。 4. 更多更详细的解释： 区块链入门知识 区块链知识点大全。。。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"区块链","slug":"区块链","permalink":"http://github.com/tags/区块链/"}]},{"title":"微信小程序","slug":"微信小程序","date":"2018-07-24T14:32:23.000Z","updated":"2018-10-28T03:05:24.927Z","comments":true,"path":"2018/07/24/微信小程序/","link":"","permalink":"http://github.com/2018/07/24/微信小程序/","excerpt":"今天开始学习微信小程序制作","text":"今天开始学习微信小程序制作 1. 登录 微信公众平台 点击登录， 账号：208781239@qq.com 密码：大写 微信扫码验证登录 2. 看官网 看简易教程-微信小程序开始学习 微信小程序学习资源 3. 自主完成静态图片集 本地预览","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://github.com/tags/小程序/"}]},{"title":"Vue继续学习","slug":"Vue继续学习","date":"2018-07-22T14:32:23.000Z","updated":"2019-09-14T07:31:49.592Z","comments":true,"path":"2018/07/22/Vue继续学习/","link":"","permalink":"http://github.com/2018/07/22/Vue继续学习/","excerpt":"Vue继续学习","text":"Vue继续学习 1.vue脚手架搭建搞定 vue_test文件夹，cnpm run dev 启动本地服务器 2.官网基础知识学习","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://github.com/tags/vue/"}]},{"title":"hexo如何使html文件不被解析","slug":"hexo搭建个人博客总结（四）","date":"2018-07-20T14:32:23.000Z","updated":"2018-12-20T08:18:01.746Z","comments":true,"path":"2018/07/20/hexo搭建个人博客总结（四）/","link":"","permalink":"http://github.com/2018/07/20/hexo搭建个人博客总结（四）/","excerpt":"hexo如何使html文件不被解析","text":"hexo如何使html文件不被解析 1.hexo如何使html文件不被解析在不想被渲染的 html 文件最上面添加如下代码123---layout: false--- 2.hexo如何使md文件不被解析使用上面的办法虽然不会渲染 md 文件，但是还是将 md 文件转化成了 html 文件，如果想保留原 md 文件后缀要怎么做呢？这就需要在 站点配置文件 _config.yml 中配置，找到 skip_render 参数，开始匹配的位置是基于你的 source_dir 的，一般来说，是你的 source 文件夹下。下面我分别列举几种常见的情况进行说明：` skip_render: test/* 单个文件夹下全部文件`skip_render: test/*.md 单个文件夹下指定类型文件`skip_render: test/** 单个文件夹下全部文件以及子目录` 123skip_render: README.md - `test1/*.html` - `test2/**` 3.hexo总结渲染html文件1）首先要先设置不被hexo渲染模式，然后再在hexo文件里进行调用2）模仿已经完成例子(查看已完成例子)","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"个人简历","slug":"个人简历封面","date":"2018-06-09T08:32:23.000Z","updated":"2019-02-28T15:22:06.313Z","comments":true,"path":"2018/06/09/个人简历封面/","link":"","permalink":"http://github.com/2018/06/09/个人简历封面/","excerpt":"了解更多","text":"了解更多 林泽坚 求职意向：前端工程师 个人简历 大二本科在校生，现正就读于广东工业大学，对前端很感兴趣，所以加入本校的一个前端工作室 ，至今已接触前端有七八个月了，熟悉html、css、js基本语法，专攻vue框架，对其它一些流行框架止于知晓理解。 技能证书 计算机二级 中级软件工程师 英语六级 基本信息 出生年月 1999.05.09 联系电话 15521035856 联系邮箱 208781239@qq.com 居住地址 广州市天河区广东工业大学（龙洞校区） 实习经验 2016.09-2017.21 &amp;nbsp|| &amp;nbsp xx公司 &amp;nbsp|| &amp;nbsp 职位 还没开始实习，有待加油！！！ 2016.09-2017.21 &amp;nbsp|| &amp;nbsp xx公司 &amp;nbsp|| &amp;nbsp 职位 占个位置先 个人技能 vue框架 专攻vue框架，通过结合node.js搭建vue脚手架做项目联系，且以此搭建 个人简易网站（） 第二个网站 通过node.js与hexo结合搭建架构，再上传至git实现网络 访问，网站记录学习的进度与心得 数据库设计 Java课程设计–简易员工管理系统，经老师同意，通过对JQ-EasyUI框架的使用、Mysql数据库的 建立连接，运用PHP相关语法进行搭建，实现管理系统的基础操作与数据交互 教育背景 2016.09-至今 &amp;nbsp|| &amp;nbsp 广东工业大学 &amp;nbsp|| &amp;nbsp 信息与计算科学 现正就读于广东工业大学应用数学学院信息与计算科学专业， 主修数学类课程（高等代数，数学分析，数据结构，数值分析，数学建模 概率论与数理统计）与部分编程语言基础（c，c++，Java） 2018大三学年荣获奖学金 努力看看能不能拿一个呀！！ 个人评价 平易近人，乐于交友是我最大的优势；时间感极强，会谨记与提前准备， 从不打无准备的战；勤勤恳恳，对承诺的事积极负责； 一份惨不忍睹的简历，现就这样吧，后面再重新写一份。。。。","categories":[],"tags":[{"name":"简历","slug":"简历","permalink":"http://github.com/tags/简历/"}]},{"title":"Vue学习总结","slug":"Vue学习总结","date":"2018-05-23T04:42:17.000Z","updated":"2019-09-14T06:50:02.563Z","comments":true,"path":"2018/05/23/Vue学习总结/","link":"","permalink":"http://github.com/2018/05/23/Vue学习总结/","excerpt":"Vue是一套用于构建用户界面的渐进式框架","text":"Vue是一套用于构建用户界面的渐进式框架 1.Vue官网Vue官网w3c Vue教程先看官网的知识流程跟着学习，之后再去看一些视频； 2.Vue安装 1.基于git下的安装参考网站：https://segmentfault.com/a/1190000008922234 2.通过cmd命令提示符参考网站：http://www.cnblogs.com/ganmy/p/6029774.html 3.html中文件引入 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"&gt;&lt;/script&gt; 指令总结：1.新建项目：vue init webpack vue_test(项目文件夹名)2.进入项目文件夹：cd vue_test（项目名），回车3.安装依赖文件：cnpm install4.运行（打开）服务器：cnpm run dev（或 npm run dev）5.查看：浏览里输入：localhost:8080(默认端口为8080)（或 localhost:8081)6.停止、关闭：Ctrl+c7.配置刷新：即先停止服务器、再重启 3.Vue安装后文件夹介绍1.2.3.4.组件模板12345678910111213141516171819&lt;template&gt; &lt;div class=\"users\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"users\", data()&#123; return &#123; &#125; &#125;, methods:&#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 5.炸了不知道哪里出问题了,本地服务器打不开,瞎搞之后更糟,准备重装了(笑脸) 4.重装，重新学习5.一个vue的简单模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset = \"utf-8\"&gt; &lt;title&gt;vue 模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = \"app\"&gt; &lt;ul&gt; &lt;li v-for = \"book in books\"&gt;&#123;&#123;book.name&#125;&#125; /*&#123;&#123;文本插值，双向绑定，动态更新&#125;&#125;*/&lt;/li&gt; &lt;/ul&gt; &lt;my-component&gt; /*渲染后为：&lt;p class = \"article\"&gt; 一些文本&lt;/p&gt;*/ &lt;/my-component&gt; &lt;/div&gt;&lt;script src = \"http://Unpkg.com/vue/dise/vue.min.js\"&gt;&lt;/script&gt; /*vue.js引入*/&lt;script&gt; /*定义组件，在Vue实例创建之前*/ Vue.component('my-component',&#123; template:'&lt;p class = \"article\"&gt; 一些文本&lt;/p&gt;' &#125;) /*Vue实例创建*/ new Vue(&#123; el: \"#app\", /*DOM 挂钩，id绑定*/ data: &#123; /*data 数据存储于绑定*/ books: [ /*for循环*/ &#123;name: \"&lt;&lt;Vue&gt;&gt;\"&#125;, &#123;name: \"&lt;&lt;Html&gt;&gt;\"&#125;, &#123;name: \"&lt;&lt;Css&gt;&gt;\"&#125;, &#123;name: \"&lt;&lt;Javascript&gt;&gt;\"&#125; ] &#125;, created: function()&#123; /*Vue实例创建完调用*/ &#125;, mounted: function()&#123; /*el挂载到实例上后调用*/ &#125;, beforeDestory: function()&#123; /*实例销毁之前调用*/ &#125;, filters: function()&#123; /*过滤器，设定过滤条件*/ &#125;, methods: &#123; fun: function()&#123; /*v-on 事件绑定，声明相关的函数方法*/ &#125; &#125;, computed: function()&#123; /*计算属性，对设定的内容动态执行与更新，有getter与setter方法*/ &#125; &#125;)&lt;/script&gt; 。。。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"学习进度","slug":"学习进度","permalink":"http://github.com/tags/学习进度/"},{"name":"Vue","slug":"Vue","permalink":"http://github.com/tags/Vue/"}]},{"title":"前端学习路线与2018热门技术","slug":"前端学习路线","date":"2018-05-23T03:42:17.000Z","updated":"2019-08-31T12:24:05.310Z","comments":true,"path":"2018/05/23/前端学习路线/","link":"","permalink":"http://github.com/2018/05/23/前端学习路线/","excerpt":"一步一步来(前端网没了，待重新整理)","text":"一步一步来(前端网没了，待重新整理) 1.一个通用的基本前端学习路线参考网站：https://blog.csdn.net/u011047006/article/details/52597178网站详细地介绍了每个阶段的学习任务，以及一些需要掌握的知识点 2.2018热门技术上面的知识点是基础，但我们也要与时俱进，了解与学习最新的技术，下面有两个总结得不错的网站了解一下 2018年前端技术趋势预览 2018的到来，前端大牛们开始关注的那些新的语言，框架和工具 3.个人想法看完2018热门技术后，自己想学一下Vue，分配好时间学习一下；","categories":[],"tags":[{"name":"路线","slug":"路线","permalink":"http://github.com/tags/路线/"}]},{"title":"flex布局了解","slug":"flex布局了解","date":"2018-05-23T02:42:17.000Z","updated":"2018-05-23T03:35:22.881Z","comments":true,"path":"2018/05/23/flex布局了解/","link":"","permalink":"http://github.com/2018/05/23/flex布局了解/","excerpt":"Flex 布局，可以简便、完整、响应式地实现各种页面布局。","text":"Flex 布局，可以简便、完整、响应式地实现各种页面布局。 1.了解flex布局 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 更多参考阮一峰大神的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"之前收集的知识点(四)","slug":"之前收集的知识点(四)","date":"2018-05-15T14:32:23.000Z","updated":"2018-05-14T17:07:59.138Z","comments":true,"path":"2018/05/15/之前收集的知识点(四)/","link":"","permalink":"http://github.com/2018/05/15/之前收集的知识点(四)/","excerpt":"浏览器零碎知识","text":"浏览器零碎知识 发布于： 2018.4.17 &nbsp;&nbsp; | &nbsp;&nbsp; 阅读： 01&nbsp;&nbsp; | &nbsp;&nbsp; 标签： 知识点 浏览器零碎知识，多读多背。。。。。。 一、引发回流（Reflow）的操作：（1）改变DOM元素的大小或位置：（2）增加、删除 DOM 结点时。（3）Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。（4）设置 style 属性的值。注：display:none 会触发 reflow，而 visibility:hidden 只会触发repaint，因为没有发现位置变化。Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。二、浏览器解析大概的工作流程大致可归纳为四个步骤：一个渲染引擎大致包括HTML解释器，CSS解释器，JavaScript引擎解析渲染该过程主要分为以下4个步骤：（1）用HTML解析器解析HTML生成DOM树，放在内存上，（2）用CSS解析器解析CSS并附着在DOM树上，生成Render树，放在内存上，（3）把Render树布局到浏览器上（4）把Render树绘制到浏览器上重绘：尺寸和位置没有变化回流：尺寸或位置有变化 三、http请求的过程：（1）浏览器查找当前URL是否存在本地缓存（2）浏览器开启线程，解析URL，通过CDN、DNS找到服务器（3）浏览器通过三次握手，与服务器建立连接（4）浏览器请求报文–服务器响应报文–浏览器接受数据–浏览器渲染页面（5）浏览器与服务器通过四次挥手，断开连接四、主要浏览器的内核及其前缀（1）IE trident -ms-（2）欧朋 presto -o-（3）谷歌 webkit -webkit-（4）火狐 gecko -moz-五、栈和队列的区别（1）栈：先进后出 （2）队列：先进后出六、验证用户是否登录的逻辑：1)用户密码登录时，在后台的req中记住session.2)如果用户保存登录密码，则记住cookie，否则把当前用户的cookie设置为空;3)每次用户需要向后台进行请求时，进行状态检验：session是否存在？若存在，则继续进行请求操作，并将session的有效时间重新设置一次；若session不存在，则判断cookie是否存在？若存在，使用该cookie完成自动登录，即完成了一次 “ 在后台的req中记住session ” );若不存在，则页面重定向到登录页面。来源： http://blog.csdn.net/xixi880928/article/details/69389337 七、怎么让Chrome支持小于12px 的文字？span{font-size: 12px;display: inline-block;-webkit-transform:scale(0.8);} 八、前端路由与单页页面 1、路由就是指随着浏览器地址栏的变化，展示给用户的页面也不相同。2、传统的网页根据用户访问的不同的地址，浏览器从服务器获取对应页面的内容展示给用户。这样造成服务器压力比较大，而且用户访问速度也比较慢。在这种场景下，出现了单页应用。3、单页应用，就是只有一个页面，用户访问一个网址，服务器返回的页面始终只有一个，就算用户改变了浏览器地址栏的内容且页面发生了跳转，服务器不会重新返回新的页面。4、优点：（1）没有了网络延迟，用户体验会有相当大的提升。后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。（2）前端路由做单页面网页，页面变了Url也会变，用户能复制到想要的url。用ajax请求做不到这一点5、缺点：（1）首次加载时间相对较长。在第一次加载的时候，需要将所有前端资源进行加载，前端资源会比多页面应用大一些，加载时间相对较长。（2）对搜索引擎不友好： 单页应用只有一个页面，无法对每一个路由做SEO。（3）没有合理地利用缓存：使用浏览器的前进，后退键的时候会重新发送请求。 九、扩展谷歌浏览器插件的步骤（以“React Developer Tools”为例）：（1）打开http://www.cnplugins.com/，（2）在“输入Chrome插件名称”里输入“React Developer Tools”（3）点击“插件下载”（4）点击“高速下载器下载”（5）打开chrome://downloads/找到“React Developer Tools”（6）打开chrome://extensions/ ，并将React Developer Tools”拖拽至这个页面十、清除缓存（1）用ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control。xmlHttp.setRequestHeader(“If-Modified-Since”,”0”);xmlHttp.setRequestHeader(“Cache-Control”,”no-cache”);（2）直接用cache:false（3）用随机数（4）随机时间十一、不同页面之间的通信（1）使用localStorage+storageA、使用localStorage.setItem(key,value);添加内容B、使用storage事件监听添加、修改、删除的动作（2）使用cookie+setInterval （3）iframe（4）postmessage 十二、window对象window对象是相对于web浏览器而言的，它并不是ECMAScripta规定的内置对象，内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”window对象是宿主对象也就是在一定的环境中才会生成的对象（这里也就是指浏览器），而global对象是在任何环境中都存在的。window对象具体也就是指浏览器打开的那个窗口。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"之前收集的知识点(三)","slug":"之前收集的知识点(三)","date":"2018-05-15T12:32:23.000Z","updated":"2018-05-14T17:01:56.751Z","comments":true,"path":"2018/05/15/之前收集的知识点(三)/","link":"","permalink":"http://github.com/2018/05/15/之前收集的知识点(三)/","excerpt":"一些js简单的扩展方法、小技巧","text":"一些js简单的扩展方法、小技巧 发布于： 2018.4.17 &nbsp;&nbsp; | &nbsp;&nbsp; 阅读： 00&nbsp;&nbsp; | &nbsp;&nbsp; 标签： 小插件、小技巧 内容：就是扩展方法与c#的扩展方法非常相似，也是可以莲师调用，也是对某个类的扩展写法来实现。所以可以将一些方法写好放在一个js里面，需要时再引用。 小技巧 1、将彻底屏蔽鼠标右键 oncontextmenu=”window.event.returnValue=false” < table border oncontextmenu=return(false)>< td>no< /table> 可用于 Table 2.取消选取、防止复制 < body onselectstart=”return false”> 3.JS不允许粘贴 onpaste=”return false” 4.JS防止复制 oncopy=”return false;” oncut=”return false;” 5.IE 地址栏前换成自己的图标 < link rel=”Shortcut Icon” href=”favicon.ico”> 在文件的根目录放进去这个图片，后缀修改成ico就可以了 6.可以在收藏夹中显示出你的图标 < link rel=”Bookmark” href=”favicon.ico”> 7.关闭输入法 < input style=”ime-mode:disabled”> 8.永远都会带着框架 < script language=”JavaScript”>< !– if (window == top)top.location.href = “frames.htm”; //frames.htm 为框架网页 // –>< /script> 9.防止被人 frame < SCRIPT LANGUAGE=JAVASCRIPT>< !– if (top.location != self.location)top.location=self.location; // –>< /SCRIPT> 10.网页将不能被另存为 < noscript>< iframe src=*.html>< /iframe>< /noscript> < input type=button value=查看网页源代码 onclick=”window.location = “view-source:”+ “http://www.pconline.com.cn””>; 12.删除时确认 < a href=”javascript:if(confirm(” 确 实 要 删 除 吗 ?”))location=”boos.asp?&areyou= 删 除 &page=1″”>删除< /a> 13.取得控件的绝对位置 //Javascript < script language=”Javascript”> function getIE(e){ var t=e.offsetTop; var l=e.offsetLeft; while(e=e.offsetParent){ t+=e.offsetTop; l+=e.offsetLeft; } alert(“top=”+t+”/nleft=”+l); } < /script> //VBScript < script language=”VBScript”>< !– function getIE() dim t,l,a,b set a=document.all.img1 t=document.all.img1.offsetTop l=document.all.img1.offsetLeft while a.tagName< >”BODY” set a = a.offsetParent t=t+a.offsetTop l=l+a.offsetLeft wend msgbox “top=”&t&chr(13)&”left=”&l,64,”得到控件的位置” end function –>< /script> 13.光标是停在文本框文字的最后 < script language=”javascript”> function cc() { var e = event.srcElement; var r =e.createTextRange(); r.moveStart(“character”,e.value.length); r.collapse(true); r.select(); } < /script> < input type=text name=text1 value=”123″ onfocus=”cc()”> 14.判断上一页的来源 javascript: document.referrer 15.最小化、最大化、关闭窗口 < object id=hh1 classid=”clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11″> < param name=”Command” value=”Minimize”>< /object> < object id=hh2 classid=”clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11″> < param name=”Command” value=”Maximize”>< /object> < OBJECT id=hh3 classid=”clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11″> < PARAM NAME=”Command” VALUE=”Close”>< /OBJECT> < input type=button value=最小化 onclick=hh1.Click()> < input type=button value=最大化 onclick=hh2.Click()> < input type=button value=关闭 onclick=hh3.Click()> 本例适用于 IE 17.屏蔽功能键 Shift,Alt,Ctrl < script> function look(){ if(event.shiftKey) alert(“禁止按 Shift 键!”); //可以换成 ALT CTRL } document.onkeydown=look; < /script> 18.网页不会被缓存 < META HTTP-EQUIV=”pragma” CONTENT=”no-cache”> < META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache, must-revalidate”> < META HTTP-EQUIV=”expires” CONTENT=”Wed, 26 Feb 1997 08:21:57 GMT”> 或者< META HTTP-EQUIV=”expires” CONTENT=”0″> 19.怎样让表单没有凹凸感？ < input type=text style=”border:1 solid #000000″> 或 < input type=text style=”border-left:none; border-right:none; border-top:none; border-bottom: 1 solid #000000″>< /textarea> 20.< div>< span>&< layer>的区别？ < div>(division)用来定义大段的页面元素，会产生转行 < span>用来定义同一行内的元素，跟< div>的唯一区别是不产生转行 < layer>是 ns 的标记，ie 不支持，相当于< div> 21.让弹出窗口总是在最上面: < body onblur=”this.focus();”> 22.不要滚动条? 让竖条没有: < body style=”overflow:scroll;overflow-y:hidden”> < /body> 让横条没有: < body style=”overflow:scroll;overflow-x:hidden”> < /body> 两个都去掉？更简单了 < body scroll=”no”> < /body> 23.怎样去掉图片链接点击后，图片周围的虚线？ < a href=”#” onFocus=”this.blur()”>< img src=”logo.jpg” border=0>< /a> 24.电子邮件处理提交表单 < form name=”form1″ method=”post” action=”mailto:*@.com” enctype=”text/plain”> < input type=submit> < /form> 25.在打开的子窗口刷新父窗口的代码里如何写？ window.opener.location.reload() 26.如何设定打开页面的大小 < body onload=”top.resizeTo(300,200);”> 打开页面的位置< body onload=”top.moveBy(300,200);”> 27.在页面中如何加入不是满铺的背景图片,拉动页面时背景图不动 < STYLE> body {background-image:url(logo.gif); background-repeat:no-repeat; background-position:center;background-attachment: fixed} < /STYLE> 28.检查一段字符串是否全由数字组成 < script language=”Javascript”>< !– function checkNum(str){return str.match(//D/)==null} alert(checkNum(“1232142141”)) alert(checkNum(“123214214a1”)) // –>< /script> 29.获得一个窗口的大小 document.body.clientWidth; document.body.clientHeight 30.怎么判断是否是字符 if (/[^/x00-/xff]/g.test(s)) alert(“含有汉字”); else alert(“全是字符”); 31.TEXTAREA 自适应文字行数的多少 < textarea rows=1 name=s1 cols=27 onpropertychange=”this.style.posHeight=this.scrollHeight”> < /textarea> 32.日期减去天数等于第二个日期 < script language=Javascript> function cc(dd,dadd) { //可以加上错误处理 var a = new Date(dd) a = a.valueOf() a = a – dadd 24 60 60 1000 a = new Date(a) alert(a.getFullYear() + “年” + (a.getMonth() + 1) + “月” + a.getDate() + “日”) } cc(“12/23/2002”,2) < /script> 33.选择了哪一个 Radio < HTML>< script language=”vbscript”> function checkme() for each ob in radio1 if ob.checked then window.alert ob.value next end function < /script>< BODY> < INPUT name=”radio1″ type=”radio” value=”style” checked>Style < INPUT name=”radio1″ type=”radio” value=”barcode”>Barcode < INPUT type=”button” value=”check” onclick=”checkme()”> < /BODY>< /HTML> 34.脚本永不出错 < SCRIPT LANGUAGE=”JavaScript”> < !– Hide function killErrors() { return true; } window.onerror = killErrors; // –> < /SCRIPT> 35.ENTER 键可以让光标移到下一个输入框 < input onkeydown=”if(event.keyCode==13)event.keyCode=9″> 36.检测某个网站的链接速度： 把如下代码加入< body>区域中: < script language=Javascript> tim=1 setInterval(“tim++”,100) b=1 var autourl=new Array() autourl[1]=”www.njcatv.net” autourl[2]=”javacool.3322.net” autourl[3]=”www.sina.com.cn” autourl[4]=”www.nuaa.edu.cn” autourl[5]=”www.cctv.com” function butt(){ document.write(“< form name=autof>”) for(var i=1;i< autourl.length;i++) document.write(“< input type=text name=txt”+i+” size=10 value=测试中……> =》< input type=text name=url”+i+” size=40> =》< input type=button value=GO onclick=window.open(this.form.url”+i+”.value)> “) document.write(“< input type=submit value=刷新>< /form>”) } butt() function auto(url){ document.forms[0][“url”+b].value=url if(tim>200) {document.forms[0][“txt”+b].value=”链接超时”} else {document.forms[0][“txt”+b].value=”时间”+tim/10+”秒”} b++ } function run(){for(var i=1;i< autourl.length;i++)document.write(“< img src=http://”+autourl+”/”+Math.random()+” width=1 height=1 onerror=auto(“http://”+autourl+””)>;”)} run()< /script> 37.各种样式的光标 auto ：标准光标 default ：标准箭头 hand ：手形光标 wait ：等待光标 text ：I 形光标 vertical-text ：水平 I 形光标 no-drop ：不可拖动光标 not-allowed ：无效光标 help ：?帮助光标 all-scroll ：三角方向标 move ：移动标 crosshair ：十字标 e-resize n-resize nw-resize w-resize s-resize se-resize sw-resize 38.页面进入和退出的特效（有点问题） 进入页面< meta http-equiv=”Page-Enter” content=”revealTrans(duration=x, transition=y)”> 推出页面< meta http-equiv=”Page-Exit” content=”revealTrans(duration=x, transition=y)”> 这个是页面被载入和调出时的一些特效。duration 表示特效的持续时间，以秒为单位。 transition 表示使用哪种特效，取值为 1-23: 0 矩形缩小 1 矩形扩大 2 圆形缩小 3 圆形扩大 4 下到上刷新 5 上到下刷新 6 左到右刷新 7 右到左刷新 8 竖百叶窗 9 横百叶窗 10 错位横百叶窗 11 错位竖百叶窗 12 点扩散 13 左右到中间刷新 14 中间到左右刷新 15 中间到上下 16 上下到中间 17 右下到左上 18 右上到左下 19 左上到右下 20 左下到右上 21 横条 22 竖条 23 以上 22 种随机选择一种 39.在规定时间内跳转 < META http-equiv=V=”REFRESH” content=”5;URL=http://www.51js.com”>; 40.网页是否被检索 < meta name=”ROBOTS” content=”属性值”> 其中属性值有以下一些: 属性值为”all”: 文件将被检索，且页上链接可被查询； 属性值为”none”: 文件不被检索，而且不查询页上的链接； 属性值为”index”: 文件将被检索； 属性值为”follow”: 查询页上的链接； 属性值为”noindex”: 文件不检索，但可被查询链接； 属性值为”nofollow”: 文件不被检索，但可查询页上的链接。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"之前收集的知识点(二)","slug":"之前收集的知识点(二)","date":"2018-05-15T10:32:23.000Z","updated":"2018-05-14T16:58:30.790Z","comments":true,"path":"2018/05/15/之前收集的知识点(二)/","link":"","permalink":"http://github.com/2018/05/15/之前收集的知识点(二)/","excerpt":"2018前端值得关注的技术","text":"2018前端值得关注的技术 发布于： 2018.4.14&nbsp;&nbsp; | &nbsp;&nbsp;阅读： 01 &nbsp;&nbsp;| &nbsp;&nbsp;标签： 文章 2018前端值得关注的技术 1.前言2017悄然过去，2018已经来到。人在进步，技术在发展。2018年前端有哪些领域，技术值得关注，哪些技术会兴起，哪些技术会没落。下面就我个人的判断进行一个预测判断，希望能对大家起到一个参考作用！下面提及的技术，只是建议大家关注，也不是建议大家全部的都要学，而是建议大家按需学，自己觉得哪些需要学，对哪些有兴趣就学哪些！如果大家有什么工具，框架，库觉得可以推荐的，欢迎在评论区提点，让大家相互进步，学习！ 2.PWAPWA(Progressive Web Apps)由谷歌提出，用前沿的技术开发，让网页使用如同App般的体验的一系列方案。明确的一点就是：PWA就是一个网页, 可以通过前沿的技术开发出一个网页应用。自从谷歌提出PWA后，就持续的获得了业界的关注，热度可见一斑。就在今年，谷歌也宣布： PWA将获得与安卓原生应用同等的待遇与权限 。这就意味着以后的网页基本和APP将越发将近，那么关注度将会进一步的上升。资料参考：PWA 入门: 写个非常简单的 PWA 页面【转载】你的首个 Progressive Web App【转载】下一代Web应用模型：Progressive Web App 3.typeScript TypeScript由微软开发。它是JavaScript的一个超集，自由和开源的编程语言。在这个语言中，添加了可选的静态类型和基于类的面向对象编程。由下图说明typeScript和JavaScript的关系！（图片来源牧之– 从 JavaScript 到 TypeScript ） angular已经开始使用typeScript进行开发，react和vue也进一步加深对typeScript的支持。不难发现，typeScript的火热程度！资料参考：TypeScript官方文档TypeScript 资源集从 JavaScript 到 TypeScript 1 - 什么是 TypeScript （看了第一篇，别落下这个系列的几篇文章） 4.parcel能给webpack带来多大的威胁webpack 大家都知道是JavaScript模块打包工具，简单的来说就是把各个模块就行分析，编译，打包等，使产出的文件可以在浏览器中运行。（图片来源于菜鸟教程- Webpack入门教程 ）webpack的工作虽然是模块打包工具，但也能代替类似gulp等自动构建工具的部分功能！经过2017的发展，webpack的火热程度也是有目共睹。但是，但是。在2017末就出现了一个黑马： parcel 。parcel出乎了大多数人的意料，也算是2017的最大惊喜之一。说到parcel的最大优势，貌似就是webpack的最大劣势：配置和性能！parcel号称零配置，多核打包，并且使用文件缓存，在时间上比webpack快了将近10倍！（图片来源于neal的文章- 宣布 Parcel：一个快速，零配置的 Web 应用打包工具 ）从star上面而言，Parcel的关注度似乎超过了当时了webpack，热度仍在持续。webpack难用之处，我觉得就是配置繁琐，且文档不完善，看着也懵逼。至于打包时间方面，只能说没有对比就没有伤害吧。如果Parcel能做好这几点，说不准能从webpack里面分到不少肉。宣布 Parcel：一个快速，零配置的 Web 应用打包工具Parcel Vs Webpack 5.WebAssembly由谷歌, 微软, Mozilla，苹果等公司合作的一个面向Web的通用二进制和文本格式的项目。引用腾讯IVWEB团队的说法：WebAssembly是一种新的字节码格式。它的缩写是”.wasm”，.wasm 为文件名后缀，是一种新的底层安全的二进制语法。。它被定义为“精简、加载时间短的格式和执行模型”，并且被设计为Web 多编程语言目标文件格式。这意味着浏览器端的性能会得到极大提升，它也使得我们能够实现一个底层构建模块的集合，例如，强类型和块级作用域。WebAssembly刚出来的时候，甚至有开发者猜想，以后会不会是WebAssembly代替JavaScript。在这里，我的感觉就是JavaScript不会被WebAssembly代替，等待没落，而是和WebAssembly共存的关系！2017年，chrome，火狐，IE，Safari四个浏览器统一通过了WebAssembly的方案，这是很少见的情况，我所了解的是第一次出现这样的统一情况，可见四个浏览器厂商对WebAssembly的重视。至于2018年，WebAssembly会有如何的发展，这个难说，初步预测应该还是普及推广，但是还没有到普及开发使用的阶段。但是无论如果，这个都值得关注！来谈谈 WebAssembly 是个啥？为何说它会影响每一个 Web 开发者？WebAssembly 实践：如何写代码 6.react,angular,vue三驾马车 2017年，react发展的迅猛，vue更是扮演框架黑马的角色，而angular虽然关注度不如以前，但是不容忽视！在2017的调查报告里面可以看到，趋势基本上是react已经占据主流，不使用框架位居第二，angular1，angular2分列三四。中国的情况就是，react第一，vue第二vue在2017年很火，但在2018年vue的潜力不容小觑如下图（有1.2W人想使用vue）。虽然超过react的可能性不是很大，但是位置依然会提升参考资料2017JavaScript调查报告前端领域2017年有哪些变化，2018年又有怎样的期待？2017 前端大事件和趋势回顾，2018 何去何从？2017 JavaScript 现状报告：询问了23000名开发者，他们给出了这样的答案2018 年最值得关注的 JavaScript 趋势无论如何，框架这个我觉得没有最好，只有最适合。三驾马车也没有说一定要全部都要会！一下就是，如果js基础好，学习框架会比较容易上手。如果极端得不学js，直接上手框架，会很吃力，很容易懵。 7.人工智能和大数据 人工智能和大数据，不是一门技术，而是一个领域，最近两年都很火，也不止于前端。我也觉得是互联网下一波的红利。非常值得关注与学习！这也是一个流行的趋势，因此一些数据可视化的工具（echart，D3等）和人工智能的库都得以收到关注！ 8.yarn VS npm相信接触到前端工程化，模块化的开发者都不可避免的使用npm进行功能包的安装依赖。尤其是在node.js的初期，npm就是工程化的一个标配。但是2017年，npm的地位显然是收到了yarn的威胁！今年的调查结果，yarn还超越了npm。yarn的优势在于：快，安全，和一些感人细节！如果照着情况下去，差距会逐渐变大！ 参考资料 yarn, 不是又一个 npm 第三方客户端 Yarn vs npm: 你需要知道的一切 9.css in js依然备受争议？前端领域，一向是推荐结构层(html)，表现层(css)，行为层(javascript)分离。但是在react出来之后，这个准则就貌似被推翻了！因为react的组件结构，要求把html，css，javascript写在一起。很多开发者对css in js不适应甚至反对。那么在新的2018年，是否还是继续的争议下去？ 参考资料 CSS in JS 简介 精读《请停止 css-in-js 的行为》 大家对CSS in JS怎么看？ 不要再在JavaScript中写 CSS了 10.flex和grid布局更加流行以前前端页面布局的时候，inline-block，float，postion布局等。但是有了flex和grid，布局变得更加的简单。首先flex基本已经被所有的浏览器支持的，其方便的特性也受到了很多开发者的热捧！ （图片来源于阮一峰的网络日记– Flex 布局教程：语法篇 ） 而grid，网格布局号称是下一代的布局方式，但是浏览器兼容方面就没有flex那么好。但是这个也是有必要了解的。毕竟已经被W3C纳入标准了。兼容性也是进一步增强。 参考资料 Flex 布局教程：语法篇 Flex 布局教程：实例篇 CSS Grid布局：什么是网格布局 （看完这篇，建议连着看下面的几篇，都是大漠写的一个系列的文章，质量非常高） CSS Grid VS Flexbox：实例对比 11.rxjsrxjs我有稍微了解一下，但是还没用上，可能是大家对这个也是比较陌生，但是我在这里提出来，是因为觉得rxjs还是值得推荐的。引用官网的说法：RxJS 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。这个项目是 Reactive-Extensions/RxJS(RxJS 4) 的重写，具有更好的性能、更好的模块性、更好的可调试调用堆栈，同时保持大部分向后兼容，只有一些破坏性的变更(breaking changes)是为了减少外层的 API 。 参考资料 rxjs中文文档 rxjs简单入门 通俗的方式理解RxJS 12.其它方面受限于篇幅，还有几个我也认为是可以关注的简单说下。如下 小程序 首先微信小程序，自打微信小程序一出来，很多前端就吐槽。跟别人群聊的时候，很多人也提到：小程序一出来，我就认为是没前途的玩意。或者就是：灭绝APP不可能，小程序只是一个阉割版的APP，竞争厂商也不会开发小程序。还有就是：学习这个还不如关注了PWA，那个比这个更加有意义。谈到的话语大概就是这个意思，2017年，我也是比较介意开发小程序，以至于2017我压根就学过小程序。但是就在17年第四季度还是年末，微信先后宣布可以内嵌html5页面，也可以开发小游戏。让我看过了小程序又有了刚发布的热度。在18年，小程序发展如何，我是否会接触和学习开发小程序，走着瞧。但是无论都值得关注。 其次是支付宝的小程序，虽然感觉没什么新闻，但是毕竟是大厂的玩意。关注是值得关注的。至于学不学，开发不开发，另一回事！ Electron 号称开发桌面应用的一大神器。也尝试了几个官方的实例，运行很流畅，只是因为暂时不开发桌面应用，所以没怎么关注，也没学习过。2018年依然关注，甚至会学习开发！ WebVR 与 WebAR 看了所谓的相关实例，那些VR和AR的效果并不能引起我的兴趣，虽然那些实例，我也没了解过时怎么开发的。但是，对于这一块，关注还是值得的。毕竟这也算是WebVR和WebAR刚起步而已。 13.哪些技术会没落/下滑angular 前面还说到angular在前端框架里面还有很大的使用率。谷歌方面也是出到了5.x，居然在这里会出现？这里只是一个小小预测而已。2017讨论angular的情况已经是比较少了，在2018年里面angular的使用率觉得会继续下滑，但不会没落，并且在前端框架里面依然有很大的一个地位。18年，angular还是会和react和vue齐名的三大框架，只是使用者不如react和vue那样多。 jquery jquery在2018年也不会没落，只是使用率还是会进一步的减少。说到jquery，还真是一个时代的转变，在我刚接触前端的时候，jquery打天下。那个时候相对于其他的库和框架，jquery就是一个巨无霸，使用率遥遥领先。就连微软是在.net平台上支持了jquery。在刚工作的时候，潜规则就是：不会jquery，没人承认你是前端。可见当时的jquery的地位。也相信很多人对有jquery情怀。只是技术不讲情怀！ es5以下版本语法 本段内容提及的es6代表es6以上的语法，包括es7,es8。es5代表es5以下的语法，包括es3 es6经过两年的发展，方便和实用性得到了众多开发者的欢迎。2017应该是es6语法的使用比率首次超es5，在2018年，es6语法使用比率会继续的升高。而es5等语法的使用比率会继续的下滑。即使就目前开发而言，还是要使用babel把es6的语法编译成es5。 grunt 在gulp发布时，grunt的地址就已经很受影响了，现在又有打包工具代替了自动构建工具的部分工具，就显得自动构建工具的作用不如以前了，更别说市场有一个更好的构建工具了–gulp。 sea.js sea.js由国人开发，当时使用的时候还满心欢喜，终于有国人的东西登上舞台了。sea.js凭借简单，轻量等优势火极一时。但是有了es6的模块化之后，就连sea.js的作者玉伯也在微博发言：应该给 Sea.js 和 KISSY 也树一块墓碑了。 14.小结好了，关于2018的的个人对于前端这一方面的预测和一些推荐关注的就写到这里了！虽然写了这么多，但是我并不是说所有都要学，要会，而是建议大家关注，学习哪些技术看自己所需，看自己兴趣。文章提及的也只是我平常关注的，有些只是我也是只是了解，但并没有深入学或者使用。也觉得在前端这一方面，没有什么最好的工具，框架，库等，只有最适合自己的。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"之前收集的知识点(一)","slug":"之前收集的知识点(一)","date":"2018-05-15T08:32:23.000Z","updated":"2018-05-14T16:47:58.710Z","comments":true,"path":"2018/05/15/之前收集的知识点(一)/","link":"","permalink":"http://github.com/2018/05/15/之前收集的知识点(一)/","excerpt":"前端之JavaScript小结","text":"前端之JavaScript小结 发布于： 2018.4.13&nbsp;&nbsp; | &nbsp;&nbsp;阅读： 01 &nbsp;&nbsp;| &nbsp;&nbsp;标签： 知识点 经验总结之javascript篇，此篇文章主旨是记录js中常见，易犯错，重要等相关知识点（不定期更新） window.onload和document.ready的区别 window.onload是在页面中包含图片在内的素有元素全部加载完成； document.ready是文档结构加载完成，但不包含图片，其他媒体文件； 在jQuery中会看到$(function(){})和$(document).ready(function(){})，是在DOM树加载完成之后执行； window.onload是在DOM树加载完以及所有文件加载完成才执行，因此慢于document.ready。 同步和异步 同步：由于js单线程，同步任务都在主线程排队执行，前面任务没执行完，后面任务一直等待； 异步：不进入主线程，进入任务队列，等待主线程任务执行完成，开始执行。最基础的异步操作setTimeout和setInterval，主线程任务执行完成，开始执行里面的函数 返回false的几种情况 false，null，0，“”，undefined，NaN js类型值的区别 存储地： 简单数据类型：存储在栈中； 引用数据类型：存储在堆中，在栈中存储了指针，指向存储在堆中的地址，解释器会先检索在栈中的地址，从堆中获得实体； 大小： 简单数据类型：大小固定，占用空间小，频繁使用，所以存储在栈中； 引用数据类型：大小不固定，占用空间大； this的指向全局范围：指向window（严格模式下不存在全局变量，指向undefined）; 普通函数调用：指向window; 对象方法调用：指向最后调用它的对象； 构造函数调用：指向new出来的对象； 显示设置this：call，apply方法显示将this指向第一个参数指明的对象； new具体做了些什么 创建一个新对象foo；并将它的proto指向其构造函数的prototype，foo.proto = Foo.prototype;动态将this指向新对象，Foo.apply(foo，arguments);执行函数体中的代码；放回新对象foo; 原型和原型链 创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。 Function.prototype.a = “a”; Object.prototype.b = “b”; function Person(){} console.log(Person); //function Person() let p = new Person(); console.log(p); //Person {} 对象 console.log(p.a); //undefined console.log(p.b); //bp.proto === Person.prototype；Person.prototype.constructor === Person当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的proto属性中调用查找，也就是它构造函数的prototype中调用查找，如果构造函数中也没有该属性方法，则会去构造函数的隐式原型中查找，一直到null，就这样形成原型链。### 数组去重 var arr = [‘a’,’bb’,’22’,’a’,’yuci’,’haha’,’22’]; 1. es6的set()方法 var unique = new Set(arr); console.log(Array.from(unique)); 2. 使用push() var arr2 = []; for(var i = 0; i &lt; arr.length; i++) { &nbsp;&nbsp;&nbsp;&nbsp;(function(i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr2.indexOf(arr[i]) == -1) { //不包含某个值则返回-1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr2.push(arr[i]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(i)) } console.log(arr2); //如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组 var arr3 = [arr[0]];for(var i = 1; i &lt; arr.length; i++) { &nbsp;&nbsp;&nbsp;&nbsp;(function(i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(arr.indexOf(arr[i]) == i) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr3.push(arr[i]); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;}(i)) } console.log(arr3); 3. 排序去除相邻重复元素 var arrSort = arr.sort();var arr4 = [];for(let i = 0; i&lt; arrSort.length; i++) {if(arrSort[i] != arrSort[i+1]) {arr4.push(arrSort[i]);}}console.log(arr4); 4. 使用splice() var len = arr.length;for(let i = 0; i &lt; len; i++) {for(let j = i + 1; j &lt; len; j++) {if(arr[i] === arr[j]) { arr.splice(i,1); len–; j–;}}}console.log(arr); 事件委托 创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。var oUl = document.getElementById(‘oul’);oUl.addEventListener(‘click’, function(e) {var e = e||window.event;var tar = e.target;if(tar.nodeName === ‘LI’) { alert(tar.innerHTML);}}) 闭包 何为闭包：有权访问另一个作用域中变量的函数闭包特性：可实现函数外访问函数内变量，外层变量可以不被垃圾回收机制回收为什么？怎么解决？for(var i = 0; i &lt; 10; i++) {setTimeout(function() {console.log(i);}, 1000);} 输出结果都为10，因为for()循环过程中每次传值，匿名函数并没有执行，相当于执行10次function(){console.log(i);}，循环结束i变为10，所以输出全部为10使用闭包，自执行匿名函数包裹for(var i = 0; i &lt; 10; i++) {(function(j) {setTimeout(function() { console.log(j);}, 1000);})(i);} 外部匿名函数立即执行，把 i 作为参数，赋值给 j ，因为是立即执行，所以每次循环输出不同值。引用外层变量不被回收，会相比其他函数占用更高内存，使用不当容易造成内存泄漏。继承方式 Child()的原型作为Parent()的实例来继承Parent()的方法属性. 因为所有实例都继承原型方法属性，其中一个实例对原型属性值更改后，所有实例调用该属性的值全部更改function Parent() {}Parent.prototype.parentSay = function() {return ‘i am parent’;}function Child() {}Child.prototype.childSay = function() {return ‘i am child’;}Child.prototype = new Parent();var par = new Parent();var kid = new Child();console.log(kid.parentSay()); //i am parent 构造函数继承：在子类的构造函数内部通过call或apply来调用父类构造函数 无法实现函数的复用function People() {this.name = [‘zhangsan’,’lisi’,’wangwu’];}function Person() {People.call(this);}var per1 = new Person();per1.name.push(‘zhanliu’);console.log(per1.name); //[“zhangsan”, “lisi”, “wangwu”, “zhanliu”]var per2 = new Person();console.log(per2.name); //[“zhangsan”, “lisi”, “wangwu”] 组合继承： 将原型链继承和构造函数继承结合，最常用的继承模式 原型链继承共享的属性和方法，构造函数继承实例属性function People(num) {this.num = num;this.name = [‘zhangsan’,’lisi’,’wangwu’];}People.prototype.numCount = function() {console.log(this.num);}function Person(num) {People.call(this, num);}//继承方式Person.prototype = new People();Person.prototype.constructor = Person;var per1 = new Person(10);per1.name.push(‘zhaoliu’);console.log(per1.name); //[“zhangsan”, “lisi”, “wangwu”, “zhanliu”]per1.numCount(); //10var per2 = new Person(20);console.log(per2.name); //[“zhangsan”, “lisi”, “wangwu”]per2.numCount(); //20 数组常用方法 改变原数组： 尾部删除pop()，尾部添加push()，头部删除shift()，头部添加unshift()，排序sort()，颠倒数组元素reverse()，删除或插入元素splice(); 不会改变元素组： 合并数组concat()，拼接数组元素join()，截取元素slice()，indexOf()，lastIndexOf()，toString()数据存储 Cookie：用于客户端与服务端通信，也具有本地存储的功能 localStorage，sessionStorage：专门用于存储区别： 大小：Cookie容量为4K，因为用于客户端与服务端通信，所有http都携带，如果太大会降低效率； localStorage，sessionStorage大小为5M。 失效时间：Cookie会在浏览器关闭时删除，除非主动设置删除时间；localStorage一直都在直到用户主动删除或清除浏览器缓存；sessionStorage在浏览器关闭时删除结束语多看看，多记忆","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"面试题整理（html、css篇）（四）","slug":"整理一些常见的面试题（四）","date":"2018-05-03T16:10:34.000Z","updated":"2018-05-05T03:33:15.514Z","comments":true,"path":"2018/05/04/整理一些常见的面试题（四）/","link":"","permalink":"http://github.com/2018/05/04/整理一些常见的面试题（四）/","excerpt":"参考不少的网站，总结出下面一些知识点，多了解了解、、、","text":"参考不少的网站，总结出下面一些知识点，多了解了解、、、 1.CSS盒子模型 内容(content)、填充(padding)、边框(border)、边界(margin) Box Model叫盒子模型（或框模型），Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。在HTML文档中，每个元素（element）都有盒子模型，所以说在Web世界里（特别是页面布局），Box Model无处不在。 Box-Model 11.由内而外依次是元素内容（content）、内边矩（padding-top、padding-right、padding- bottom、padding-left）、边框（border-top、border-right、border-bottom、border- left）和外边距（marging-top、margin-right、margin-bottom、margin-left）;2.内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。而且，外边距可以是负值，而且在很多情况下都要使用负值的外边距。 W3School的Box Model 21.元素框的最内部分是实际的内容（element）；直接包围内容的是内边距（padding），内边距呈现了元 素的背景（background）；内边距的边缘是边框（border）；边框以外是外边距（margin），外边距默认是透明的，因此不会遮挡其后的任 何元素（其实元素的margin就是其所在父元素的padding）。元素的背景应用于由内容和内边距、边框组成的区域。2.内边距、边框和外边距都是可选的，默认值是零。可以通过将元素的 margin 和 padding 设置为零来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器 `（）`对所有元素进行设置：1234/*设置所有元素的外边距和内边矩为0*/* &#123; margin: 0; padding: 0;&#125; 3.在 CSS 中，width 和 height 指的是内容区域（element）的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。假设框的每个边上有 10 个像素的外边距和 5 个像素的内边距。如果希望这个元素框达到 100 个像素，就需要将内容的宽度设置为 70 像素，以下是CSS代码：12345#box &#123; width: 70px; margin: 10px; padding: 5px;&#125; 如下图：参考网站：https://my.oschina.net/sheila/blog/384806 2.HTML语义化 按照人们的思考逻辑命名，不但要自己能看懂，也要让别人也能看懂，不要让别人觉得你的代码很乱。语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用。语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。 语义化命名： 文件命名：main.css（主要的文件） 注释命名： /* Footer */ 内容区 /* End Footer */（主要的文件）* id命名： 页头：header；内容：content/container class命名： ”类别+功能/分类”命名；.titleBar-news{ }/新闻标题栏/* 更多请参考：CSS语义化命名及常用命名规则（推荐） 3.div水平居中 知道DIV的自身长度和宽度： 首们需要position:absolute;绝对定位。 而层的定位点，使用外补丁margin负值的方法。负值的大小为层自身宽度高度除以二，[style=”position: absolute;top:50%;left: 50%”]只能实现DIV离左边框和上边框的距离为屏幕的物理尺寸的一半，忽略了DIV本身的长度和宽度，所以不会实现DIV的水平垂直居中。 不知道DIV的本身长度和宽度时: 1234567$(window).load(function()&#123; $(\".mydiv\").css(&#123; position: \"absolute\", left: ($(window).width() - $(\".mydiv\").width())/2, top: ($(window).height() - $(\".mydiv\").height())/2 &#125;); &#125;); div绝对定位水平垂直居中【margin:auto实现绝对定位元素的居中】 1234567891011div&#123; width: 200px; height: 200px; background: green; position:absolute; left:0; top: 0; bottom: 0; right: 0; margin: auto; &#125; //兼容性：,IE7及之前版本不支持 div绝对定位水平垂直居中`【Transforms 变形】` 123456789div&#123; width: 200px; height: 200px; background: green; position:absolute; left:50%; /* 定位父级的50% */ top:50%; transform: translate(-50%,-50%); /*自己的50% */ &#125; //兼容性：IE8不支持； css不定宽高 水平垂直居中 12345678910111213.box&#123; height:600px; display:flex; justify-content:center; align-items:center; /* aa只要三句话就可以实现不定宽高水平垂直居中。 */ &#125; .box&gt;div&#123; background: green; width: 200px; height: 200px; &#125; 4.div垂直居中 1.绝对定位的 div，把它的 top 设置为 50％，top margin 设置为负的 content 高度。这意味着对象必须在 CSS 中指定固定的高度。 12345678&lt;div class=\"content\"&gt; Content goes here&lt;/div&gt;#content &#123; position: absolute; top: 50%; height: 240px; margin-top: -120px; /* negative half of the height */&#125; 2.使用 margin:auto;使块级元素垂直居中:使用了一个 position:absolute，有固定宽度和高度的 div。这个 div 被设置为 top:0; bottom:0;。但是因为它有固定高度，其实并不能和上下都间距为 0，因此 margin:auto; 会使它居中. 123456789101112&lt;div id=\"content\"&gt; Content here&lt;/div&gt; #content &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 240px; width: 70%;&#125; 3.单行文本置中:把 line-height 设置为那个对象的 height 值就可以使文本居中了 123456&lt;div id=\"content\"&gt; Content here&lt;/div&gt; #content &#123; height: 100px; line-height: 100px;&#125; HTML5一个新增属性———— data- 自定义属性在HTML5中我们可以使用以 data- 为前缀来设置我们需要的自定义属性，来进行一些数据的存放。123456789&lt;div id = \"user\" data-uid = \"12345\" data-uname = \"愚人码头\" &gt; &lt;/div&gt;// 使用getAttribute获取 data- 属性var user = document . getElementById ( 'user' ) ;var userName =user . getAttribute ( 'data-uname' ) ; // userName = '愚人码头'var userId = user . getAttribute ( 'data-uid' ) ; // userId = '12345'使用setAttribute设置 data- 属性user . setAttribute ( 'data-site' , 'http://www.css88.com' ) ; 参考网站：https://www.qdfuns.com/article/44791/edb15b7b6a931231751651fbab1c11b7.html","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"html","slug":"html","permalink":"http://github.com/tags/html/"},{"name":"面试题","slug":"面试题","permalink":"http://github.com/tags/面试题/"},{"name":"css","slug":"css","permalink":"http://github.com/tags/css/"}]},{"title":"面试题整理（js篇）（三）","slug":"整理一些常见的面试题（三）","date":"2018-05-03T13:42:17.000Z","updated":"2018-05-09T03:33:15.881Z","comments":true,"path":"2018/05/03/整理一些常见的面试题（三）/","link":"","permalink":"http://github.com/2018/05/03/整理一些常见的面试题（三）/","excerpt":"一些生涩的js知识点，可以了解一下","text":"一些生涩的js知识点，可以了解一下 1.cookie 和 session 当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择都纪录下来； 当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id 2.MVC 和 BFC mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js； BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。 3.动态节点绑定事件Live（） delegate（） bind（）【处理文档中的静态部分，不用于。。。】123456789101112131415161718delegate()和live（）作用类似，附加的事件处理程序适用于匹配选择器的当前及未来的元素（比如由脚本创建的新元素）。但二者参数不一样$(selector).delegate(childSelector,event,function)$(selector).live(event,function)$(\"div\").delegate(\"p\",\"click\",function()&#123;$(this).slideToggle();&#125;);//只有DIV内的p元素会被绑定事件。$(\"p\").live(\"click\",function()&#123;$(this).slideToggle();&#125;);//文档内所有p元素都会被绑定事件bind（）可以向元素添加的一个或多个事件处理程序，以及当事件发生时运行的函数。$(selector).bind(event,function)$(\"button\").bind(\"click\",function()&#123;$(\"p\").slideToggle();&#125;);//bind【捆绑】 4.参考网站：史上前端面试最全问答（附答案）原型与继承：深入解读 JavaScript 中的面向对象编程","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"js","slug":"js","permalink":"http://github.com/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"http://github.com/tags/面试题/"}]},{"title":"前端编辑器总结","slug":"前端编辑器","date":"2018-05-02T16:00:00.000Z","updated":"2018-05-03T01:31:06.557Z","comments":true,"path":"2018/05/03/前端编辑器/","link":"","permalink":"http://github.com/2018/05/03/前端编辑器/","excerpt":"昨天兴致勃勃打开一直在使用的前端编辑器 submit text 3 却发现要购买 key。。。那等于没用了！！！所以熬夜爆肝找了一大堆东西，终于发现干货~~~","text":"昨天兴致勃勃打开一直在使用的前端编辑器 submit text 3 却发现要购买 key。。。那等于没用了！！！所以熬夜爆肝找了一大堆东西，终于发现干货~~~ 五款前端开发编辑器 参考网址：五款前端开发编辑器测评 写得非常动人，我就不多写了，去看上面的总结！ Atom 感觉都不错，最终选了 Atom (自行下载哦！) 主要是界面跟 submit 的差不多，看起来舒服、、、 Atom插件 一款好的编辑器决定有许多便捷的工具插件，下面是一个Atom插件网址 ATOM常用插件推荐 非常详细的总结，有需要时就去安装","categories":[],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://github.com/tags/编辑器/"},{"name":"工具插件","slug":"工具插件","permalink":"http://github.com/tags/工具插件/"}]},{"title":"ES6语法总结","slug":"ES6语法总结","date":"2018-04-30T04:08:02.901Z","updated":"2018-05-23T03:35:38.868Z","comments":true,"path":"2018/04/30/ES6语法总结/","link":"","permalink":"http://github.com/2018/04/30/ES6语法总结/","excerpt":"ES6经常听到，所以去看了一些视频了解一下，加上参考他人博客，总结出下面一些重要知识点","text":"ES6经常听到，所以去看了一些视频了解一下，加上参考他人博客，总结出下面一些重要知识点 1.let 表示变量，相当于之前的 var 注意：1.没有预编译，不存在变量提升； 在代码块内，只要let定义变量，在之前使用，都是报错； 先定义完，再使用； let 是块级作用域，而 var 是函数作用域。 2.不能重复定义；但能重新赋值；3.for循环，for循环里面是父级作用域，里面又一个； 补充一个变量提升知识：在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:1234567function aa() &#123; if(bool) &#123; var test = 'hello man' &#125; else &#123; console.log(test) &#125;&#125; 而上面的代码在执行时会经过预编译环节，如下：12345678910function aa() &#123; var test // 变量提升 if(bool) &#123; test = 'hello man' &#125; else &#123; //此处访问test 值为undefined console.log(test) &#125; //此处访问test 值为undefined &#125; `注意类型的区别： 基本类型：直接存储基本类型：字符串、数值、布尔类型、null、undefined 复制类型：通过引用的方式存储复杂类型：对象、数组、函数`2.count 常量声明,定义完变量必须有值，不能之后赋值，不能修改； 声明的变量都会被认为是常量，意思就是它的值被设置完成后就不能再修改了。 12const name = 'lux'name = 'joe' //再次赋值此时会报错 还有，如果const的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址没有变就行。 12345const student = &#123; name: 'cc' &#125;// 没毛病student.name = 'yy'// 如果这样子就会报错了student = &#123; name: 'yy' &#125; 下面看一道实例面试题 1234567var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(function(func) &#123; func() &#125;) 这样的面试题是大家常见，很多同学一看就知道输出 10 十次但是如果我们想依次输出0到9呢？有两种解决方法。直接看一下代码1234567891011121314151617181920// ES5告诉我们可以利用闭包解决这个问题// 立即执行函数//(function() &#123;// return function() &#123; // &#125;//&#125;)() var funcs = [] for (var i = 0; i &lt; 10; i++) &#123; funcs.push( (function(value) &#123; return function() &#123; console.log(value) &#125; &#125;)(i) ) &#125; funcs.forEach(function(func) &#123; func() &#125;) 12345678// 再来看看es6怎么处理的 const funcs = [] for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i) &#125;) &#125; funcs.forEach(func =&gt; func()) 3.块级作用域 let和const都是块级作用域 在一个函数内部 在一个代码块内部 说白了 {}大括号内的代码块即为let 和 const的作用域。 如：let的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。12345678function aa() &#123; if(bool) &#123; let test = 'hello man' &#125; else &#123; //test 在此处访问不到 console.log(test) &#125;&#125; 4.结构赋值因为解构能减少临时引用属性 非常有用，特别是在做数据交互 ajax； (let[a,b,c] = [1,2,3]) 注意：左右两边，结构保持一致 解构时可以给初始值 let[a,b,c=&#39;默认值&#39;] = [&#39;aaa&#39;,&#39;bbb]; 5.字符串模板1.基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定引用变量,且可以随意换行。123456//ES5var name = 'lux'console.log('hello' + name)//es6const name = 'lux'console.log(`hello $&#123;name&#125;`) //hello lux 2.在ES5时我们通过反斜杠(\\)来做多行字符串或者字符串一行行拼接。ES6反引号(`)`直接搞定。12345678// ES5 var msg = \"Hi \\ man! \" // ES6 const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt; 3.字符串ES6当然也提供了很多厉害也很有意思的方法123456789101112131415161718// 1.includes：判断是否包含字符串，然后直接返回布尔值 const str = 'hahay' console.log(str.includes('y')) // true // str.indexOf(要找的东西) 返回索引（位置），没找到返回-1； // 2.repeat: 获取字符串重复n次 const str = 'he' console.log(str.repeat(3)) // 'hehehe' //如果你带入小数, Math.floor(num) 来处理 // s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理 // 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束 const str = 'hello world!' console.log(str.startsWith('hello')) // true console.log(str.endsWith('!')) // true //4.str.padStart(整个字符串长度，填充东西) 玩前填充 str.padStart(整个字符串长度，填充东西) 玩后填充 4.字符串超过 80 个字节应该使用字符串连接号换行;5.字符串连接例子：12345678910// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// goodconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 6. 函数变化 函数声明代替函数表达式因为函数声明是可命名的，所以他们在调用栈中更容易被识别。此外，函数声明会把整个函数提升（hoisted），而函数表达式只会把函数的引用变量名提升。这条规则使得箭头函数可以取代函数表达式 12345//badconst foo = function () &#123;&#125;;//goodfunction foo() &#123;&#125;; 函数的默认参数 1234function show(&#123;x=0,y=0&#125;=&#123;&#125;)&#123; console.log(x,y);&#125;show(); 函数参数默认值若已经定义，则不能再使用let、const声明 12345function show(&#123;x=10)&#123; let x = 101; //错误 console.log(x);&#125;show(); 扩展运算符–reset运算符 展开数组 … ：[1,2,3] -&gt; …[1,2,3] -&gt; 1,2,3; 1,2,3 -&gt; …1,2,3 -&gt; [1,2,3] 剩余参数，必须放到最后 箭头函数 =&gt;当你必须使用函数表达式（或传递一个匿名函数）时箭头函数最直观的三个特点： 不需要 function 关键字来创建函数 省略 return 关键字 继承当前上下文的 this 关键字 1234567//例如： [1,2,3].map(x =&gt; x + 1)//等同于： [1,2,3].map((function(x)&#123; return x + 1 &#125;).bind(this)) 12345678let show() = &#123;&#125; =&gt; 1;&#123;&#125; =&gt; return东西&#123;&#125; =&gt; &#123; 语句； return东西；&#125; 注意： this问题，定义所在的对象，不再是运行时所在的对象（即不再是函数谁调用就指向谁） 箭头函数里面没有arguments，用 ...;...能明确你要传入的参数。另外 rest 参数是一个真正的数组，而 arguments是一个类数组。 箭头函数不能当构造函数； 来道笔试题： 1234567891011121314// 请使用ES6重构以下代码 var calculate = function(x, y, z) &#123; if (typeof x != number) &#123; x = 0 &#125; if (typeof y != number) &#123; y = 6 &#125; var dwt = x % y var result if (dwt == z) &#123; result = true &#125; if (dwt != z) &#123; result = false &#125; return result &#125; 12345const calculate = (x, y, z) =&gt; &#123; x = typeof x !== 'number' ? 0 : x y = typeof y !== 'number' ? 6 : y return x % y === z &#125; 构造函数：总是使用 class ，避免直接操作 prototype为什么? 因为 class 语法更为简洁更易读。 123456789101112131415161718192021//badfunction Queue(content = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queuep[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用 extends 继承为什么：因为 extends是一个內建的原型继承方法并且不会破坏instanceof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badconst inherits = require('inherits');function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;//goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125;### 7. 数组* 1.ES5里面新增的一些东西 * 循环： 1.for循环：for(let i = 0; i &lt; arr.length; i++)&#123;&#125;; 2.while循环 * arr.forEach() //代替普通for循环 arr.forEach(function(val,index,arr)&#123; comsole.log(val,index,arr); &#125;) * arr.map() // 非常有用，做数据交互 ‘映射’； //正常情况下，需要配合return，返回一个新数组； // 若是没有return，相当于forEach； // 注意：平常用到map，一定要配合return * arr.filter() // 过滤，过滤一些不合格的“元素”； 如果函数返回turn，就留下来； * arr.some() // 类似查找，数组里面某一个元素符合条件，返回turn； * arr.every() // 数组里面所有元素都要符合条件，才返回turn；**注意： 其实他们都可以接受两个参数； 循环回调函数，this指向谁；** * arr.reduce() // 从左往右，求数组的和，阶乘 * arr.reduceRight() // 从右往左，求数组的和，阶乘* ES2017新增一个运算符： * 幂运算符： Math.pow(2,3) 相当于 2 ** 3；-----------------------------------------------------* for...of...: arr.keys() //数组下标； arr.entries() //数组某一项；```javascript for(let val of arr)&#123; console.log(val); &#125; 数组新增1.使用字面值创建数组: 12345// badconst items = new Array();// goodconst items = []; 2.向数组添加元素时使用 Arrary#push 替代直接赋值:1234567const someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 3.使用拓展运算符 … 复制数组。1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 扩展运算符 let arr = [1,2,3]; let arr2 = […arr]; let arr2 = Array.from(arr); Array.from: 作用：把类数组（获取一组元素、arguments…）对象转成数组； 个人观点：具备length这个东西，就靠谱（json没length，但添加后也可使用）； Array.of(): 把一组值，转成数组； let arr = Array.of(‘a’,’b’,’c’); arr.find(): 查找，找出一个符合条件的数组成员，如果没有找到，返回undefined； arr.findindex():找到的是位置，没找到返回-1； arr.fill(): 填充 arr.fill(填充的东西，开始位置，结束位置)； 在ES2016里面新增： arr.indexOf(); arr.includes(); 8.对象 使用字面值创建对象。 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 使用对象方法的简写： 123456789101112131415161718192021222324252627282930311.// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;;2.const lukeSkywalker = 'Luke Skywalker'; // bad const obj = &#123; lukeSkywalker: lukeSkywalker, &#125;; // good const obj = &#123; lukeSkywalker, &#125;; 9.模块1.总是使用模组 (import/export) 而不是其他非标准模块系统为什么？模块就是未来，让我们开始迈向未来吧。1234567891011// badconst AirbnbStyleGuide = require('./AirbnbStyleGuide');module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from './AirbnbStyleGuide';export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from './AirbnbStyleGuide';export default es6; 2.模块化-export和import123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//mod.js// 第一种模块导出的书写方式(一个个的导出)// 导出普通值export let a = 12;export let b = 5;// 导出jsonexport let json = &#123; a, b&#125;;// 导出函数export let show = function()&#123; return 'welcome';&#125;;// 导出类export class Person&#123; constructor()&#123; this.name = 'jam'; &#125; showName()&#123; return this.name; &#125;&#125;//index.js//导出模块如果用default了，引入的时候直接用，若没有用default，引入的时候可以用&#123;&#125;的形式// 导入模块的方式import &#123; a, b, json, show, Person&#125; from './mod.js';console.log(a); // 12console.log(b); // 5console.log(json.a); // 12console.log(json.b); // 5console.log(show()); // welcomeconsole.log(new Person().showName()); // jam//mod1.js// 第二种模块导出的书写方式let a = 12;let b = 5;let c = 10;export &#123; a, b, c as cc // as是别名，使用的时候只能用别名，特别注意下&#125;;//index1.js// 导入模块的方式import &#123; a, b, cc // cc是导出的，as别名&#125; from './mod1.js';console.log(a); // 12console.log(b); // 5console.log(cc); // 10//mod2.js// 第三种模块导出的书写方式 ---&gt; default// default方式的优点，import无需知道变量名，就可以直接使用，如下// 每个模块只允许一个默认出口var name = 'jam';var age = '28';export default &#123; name, age, default()&#123; console.log('welcome to es6 module of default...'); &#125;, getName()&#123; return 'bb'; &#125;, getAge()&#123; return 2; &#125;&#125;;//index2.js// 导入模块的方式import mainAttr from './mod2.js';var str = ' ';// 直接调用console.log(`我的英文名是:$&#123;mainAttr.name&#125;我的年龄是$&#123;mainAttr.age&#125;`);mainAttr.default(); // welcome to es6 module of default...console.log(mainAttr.getName()); // bbconsole.log(mainAttr.getAge()); // 2//mod3.jsvar name = 'jam';var age = '28';export function getName()&#123; return name;&#125;;export function getAge()&#123; return age;&#125;;//index3.js// 导入模块的方式import * as fn from './mod3.js';// 直接调用console.log(fn.getName()); // jam 10.class和extends123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//传统面向对象写法function Person(name,age)&#123; // 类、构造函数 this.name = name; this.age = age;&#125;Person.prototype.showName = function()&#123; return this.name;&#125;;Person.prototype.showAge = function()&#123; return this.age;&#125;;var p1 = new Person('allen',28);var p2 = new Person('xiaoxiaoyou',101);console.log(p1.showName()); // allenconsole.log(p2.showAge()); // 101console.log(p1.showName == p2.showName); // trueconsole.log(p1.constructor == Person); // true//ES6面向对象写法class Person&#123; // 构造器 constructor(name,age)&#123; this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125;&#125;var p1 = new Person('aaa',18);var p2 = new Person('bbb',20);console.log(p1.name); // aaaconsole.log(p1.showName()); // aaaconsole.log(p2.showAge()); // 20console.log(p1.showAge == p2.showAge); // trueconsole.log(p1.constructor == Person); // true//面向对象class给默认值class Person&#123; // 构造器 constructor(name='default',age=0)&#123; this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125;&#125;var p1 = new Person();console.log(p1.name); // 构造器里面给的默认值 defaultconsole.log(p1.age); // 构造器里面给的默认值 0//传统写法原型继承function Person(name,age)&#123; // 类、构造函数 this.name = name; this.age = age;&#125;Person.prototype.showName = function()&#123; return this.name;&#125;;Person.prototype.showAge = function()&#123; return this.age;&#125;;// 工人类function Worker(name,age)&#123; // 属性继承过来 Person.apply(this,arguments);&#125;// 原型继承Worker.prototype = new Person();var p1 = new Person('allen',28);var w1 = new Person('worker',1000);console.log(w1.showName()); // 确实继承过来了 result：worker//ES6中面向对象实现类继承class Person&#123; // 构造器 constructor(name,age)&#123; this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125;&#125;class Worker extends Person&#123; constructor(name,age,job='拖地的')&#123; // 继承超父类的属性 super(name,age); this.job = job; &#125; showJob()&#123; return this.job; &#125;&#125;var p1 = new Person('aaa',18);var w1 = new Person('www',36);var w2 = new Worker('wwwwwwww',90);console.log(w1.showName()); // wwwconsole.log(w2.showJob()); // 默认给的值 ‘拖地的’ 11.promise：承诺，许诺 作用：解决异步回调问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//传统方法：大部分回调函数，事件：ajsx(url,&#123; //获取token ajax（url,0=&gt;&#123; //获取用户信息 ajax(url,&#123;&#125;=&gt;&#123; //获取用户相关新闻 &#125;) &#125;&#125;)//Promise对象 ---&gt; 用来传递异步操作过来的数据的//Pending(等待、处理中) ---&gt; Resolve(完成，fullFilled) ---&gt; Reject(拒绝，失败)var p1 = new Promise(function(resolve,reject)&#123; resolve(1); // 成功了 // reject(2); // 失败了&#125;);// 接收成功和失败的数据，通过then来传递// then也是返回一个promise对象，会继续往下传递数据,传递给下一个thenp1.then(function(value)&#123; // resolve console.log(value); return value + 1; // 1 alert(`成功了：$&#123;value&#125;`);&#125;,function(value)&#123; // reject alert(`失败了：$&#123;value&#125;`);&#125;).then(function(value)&#123; console.log(value); // 2&#125;);//catch捕获异常错误var p1 = new Promise(function(resolve,reject)&#123; resolve('成功了');&#125;);p1.then(function(value)&#123; console.log(value); // throw是用来抛错误的 throw '发生了点小意外';&#125;).catch(function(e)&#123; // catch用来捕获这个错误的 ---&gt; 追踪 console.log(e);&#125;);//all ---&gt; 全部，用于将多个promise对象，组合，包装成//Promise.all([p1,p2,p3,...]); 所有的promise对象，都正确，才走成功//否则，只要有一个错误，就走失败var p1 = Promise.resolve(1);var p2 = Promise.reject(0);Promise.all([true,p1,p2]).then(function(obj)&#123; console.log(`成功了：$&#123;obj&#125;`);&#125;,function(obj)&#123; console.log(`失败了：$&#123;obj&#125;`);&#125;);// race ---&gt; 返回的也是一个promise对象//最先执行的的promise结果，哪个最快我用哪个var p1 = new Promise(function(resolve,reject)&#123; setTimeout(resolve,50,'one');&#125;);var p2 = new Promise(function(resolve,reject)&#123; setTimeout(resolve,100,'two');&#125;);Promise.race([p1,p2]).then(function(val)&#123; console.log(val);&#125;);//resolve ---&gt; 生成一个成功的promise对象//语法规则：Promise.resolve(val); // 普通值// Promise.resolve(arr); // 数组之类//Promise.resolve(promise); // 传递另一个promise对象//传递普通值Promise.resolve('success').then(function(val)&#123; // 注意resolve，走得是这里 console.log(val); // success&#125;,function(err)&#123; console.log(\"err:\"+ err);&#125;);//传递数组Promise.resolve([1,2,3]).then(function(val)&#123; // 注意resolve，走得是这里 console.log(val); // [1,2,3]&#125;,function(err)&#123; console.log(err);&#125;);//传递一个promise对象var p1 = Promise.resolve(520);var p2 = Promise.resolve(p1);p2.then(function(val)&#123; //从p1那边传递过来的 console.log(val); // 520&#125;); 11.Generator,yield123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//Generator ---&gt; 生成器就是一个函数//特点：//1.函数名前面带一个*，和普通函数做区分//2.内部使用yield语句//调用方式，如下var res = show();//value指的是generator函数内容yield定义的值，done:false表示还没遍历完//直接找到返回值return了，那么此时done才会为true//console.log(res.next());&#123;value:'值1',done:false&#125;function* show()&#123; yield 'Hello'; yield 'World'; yield 'ES6'; return 'xx';&#125;var res = show();console.log(res.next()); // &#123;value: \"Hello\", done: false&#125;console.log(res.next()); // &#123;value: \"World\", done: false&#125;console.log(res.next()); // &#123;value: \"ES6\", done: false&#125;console.log(res.next()); // &#123;value: \"allen\", done: true&#125;// 已经找到return返回值了，继续下去就没有意义了// console.log(res.next()); // &#123;value: \"undefined\", done: true&#125;//yield本身没有返回值，或者可以说每次给你返回的是undefinedfunction* show()&#123; var a = yield 'Hello'; return a;&#125; var res = show();console.log(res.next()); // &#123;value: \"Hello\", done: false&#125;console.log(res.next()); // &#123;value: \"undefined\", done: true&#125;//next方法是可以带参数的,死循环的generator函数function* fn()&#123; for(var i=0;true;i++)&#123; // 如果里面传了一个值，那么它会把这个参数赋给最近的一个yield var a = yield i; if(a) i = -1; &#125;&#125;var d = fn();console.log(d.next()); // &#123;value: 0, done: false&#125;console.log(d.next()); // &#123;value: 1, done: false&#125;console.log(d.next()); // &#123;value: 2, done: false&#125;// 如果里面传了一个值，那么它会把这个参数赋最近的一个yieldconsole.log(d.next(true)); // &#123;value: 0, done: false&#125;console.log(d.next()); // &#123;value: 1, done: false&#125;console.log(d.next()); // &#123;value: 2, done: false&#125;console.log(d.next()); // &#123;value: 3, done: false&#125;// for..0f循环generator函数function* fn()&#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;//for..0f循环generator函数，可以取值for(let val of fn())&#123;document.write(val); // 12345&#125;// 对象里使用generator函数的特殊写法，注意下var json = &#123; *show()&#123; yield 'a'; yield 'b'; return 'c'; &#125;&#125;;var res = json.show();console.log(res.next()); // &#123;value: \"a\", done: false&#125;console.log(res.next()); // &#123;value: \"b\", done: false&#125;console.log(res.next()); // &#123;value: \"c\", done: true&#125; 属性 使用. 来访问对象的属性 12345678910const luke = &#123; jedi: true, age: 28,&#125;;//badconst isJedi = luke['jedi'];//goodconst isJedi = luke.jedi; 当通过变量访问属性时使用中括号 [] 12345678910const luke = &#123; jedi: true, age: 28,&#125;;function getProp(prop) &#123; return luke[prop];&#125;const isJedi = getProp('jedi'); 比较运算符 &amp; 等号 优先使用===和 !== 而不是 == 和 !=。 条件表达式例如if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵循下面 的规则： 对象被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0、或NaN被计算为 false，否则为true 字符串如果是空字符串 被计算为 `false`，否则为`true`12345678910111213141516171819### 注释* 使用`/**.....*/`作为多行注释，包括描述、指定所有参数和返回值的类型和值* 使用 `//` 作为单行注释，在评论对象上面另起一行使用单行注释。在注释前插入空行。```javascript// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 更多细节参考：https://www.w3cschool.cn/rtuhtw/ 一个不错的ES6教学视频：http://study.163.com/course/courseMain.htm?courseId=1005211046参考來源：简书；作者：陈嘻嘻啊；链接：https://www.jianshu.com/p/287e0bb867ae参考來源：简书； 作者：前端工程狮_jam 链接：https://www.jianshu.com/p/384fa7cbaa63","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"ES6","slug":"ES6","permalink":"http://github.com/tags/ES6/"}]},{"title":"面试题整理（js篇）(二)","slug":"整理一些常见的面试题（二）","date":"2018-04-28T16:00:00.000Z","updated":"2018-04-29T10:42:18.783Z","comments":true,"path":"2018/04/29/整理一些常见的面试题（二）/","link":"","permalink":"http://github.com/2018/04/29/整理一些常见的面试题（二）/","excerpt":"一些较不懂的js知识点","text":"一些较不懂的js知识点 1.javascript数据变量 var let const 区别： 1.varvar定义全局变量和局部变量，也可以省略var，而且在非严格模式下不会报错，但是实际上在严格模式下，两者的使用有没有区别，可能很多人不清楚。例如循环，跳出循环依旧会有效 2.letlet拥有块级作用域,一个{}就是一个作用域，也就是let声明块级变量，即局部变量；let在其作用域下面不存在变量提升；let在其作用域中不能被重复声明(函数作用域和块级作用域)。 3.constconst用来声明常量，一旦声明，其值就不可以更改，而且必须初始化。如果你非得修改变量的值，js不会报错，只是默默表示失败(不起作用)。 2.JavaScript内置对象有以下几种。 String对象：处理所有的字符串操作 Math对象：处理所有的数学运算 Date对象：处理日期和时间的存储、转化和表达 Array对象：提供一个数组的模型、存储大量有序的数据 Event对象：提供JavaScript事件的各种处理信息 3.JavaScript内置函数①：escape( )escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。 eg:?=%3②：eval( ) eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。eg:eval(“x=10;y=20;document.write(x*y)”)③：isFinite( )isFinite() 函数用于检查其参数是否是无穷大。返回true或者false。④：isNaN( ) isNaN( ) 函数可用于判断其参数是否是 NaN⑤：parseFloat( )parseFloat() 函数可解析一个字符串，并返回一个浮点数。⑥;parseInt( ) parseInt() 函数可解析一个字符串，并返回一个整数。⑦：unescape( ) unescape() 函数可对通过 escape() 编码的字符串进行解码。 4.JavaScript对数组的操作有哪些？1.数组建立（new）2.数组元素的访问（循环）3.数组的元素添加(push末尾，unshift开头)4.数组元素的删除（pop最后，shift开头，splice(startIndex , deletSize)指定位置）5.数组元素拷贝和复制（slice(start,end)返回一个新数组，其中以start开始，end结束且不包括end;6.concat(element1[element2[]]…);将多个数组重新连成一个新的数组），7.数组元素顺序（sort();数组排序。8.reverse()；数组反转。）9.数组转化为字符串（oin(seperater)）12objArr.sort(function(a,b)&#123;return a&gt;b?1:-1&#125;);//从小到大排序objArr.sort(function(a,b)&#123;return a&lt;b?1:-1&#125;);//从大到小排序 5.JavaScript的作用域和作用域链？ 作用域 全局作用域（Global Scope）在代码中任何地方都能访问到的对象拥有全局作用域，1，最外层函数和在最外层函数外面定义的变量拥有全局作用域2，所有末定义直接赋值的变量自动声明为拥有全局作用域3，所有window对象的属性拥有全局作用域 局部作用域与全局作用于相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部 作用域链在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。 6.双向绑定的实现原理简单来说，就是监听dom事件，例如change,或者键盘回车，获取改变后的值，赋值给指定的职位，整个都是在函数中完成。有的框架，基本思路是使用Object.defineProperty对数据对象做属性get和set的监听，当有数据读取和赋值操作时则调用节点的指令，这样使用最通用的 = 等号 赋值就可以了。 7.前端框架Vue、Angular、React的优点和缺点 Vue.js的特性如下：1.轻量级的框架 2.双向数据绑定 3.指令 4.插件化 优点： 1，简单：官方文档很清晰，比 Angular 简单易学。 2，快速：异步批处理方式更新 DOM。 3， 组合：用解耦的、可复用的组件组合你的应用程序。 4，紧凑：18kb min+gzip，且无依赖。 5，强大：表达式 &amp; 无需声明依赖的可推导属性 (computed properties)。 6，对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。 缺点： 1，新生儿：Vue.js是一个新的项目，没有angular那么成熟。 2，影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库。 angular：1良好的应用程序结构2.双向数据绑定3.指令4.HTML模板5.可嵌入、注入和测试 优点：1.模板功能强大丰富，自带了极其丰富的angular指令。2.是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；3.自定义指令，自定义指令后可以在项目中多次使用。4.ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。5.angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。 缺点：1，angular 入门很容易 但深入后概念很多, 学习中较难理解.2，文档例子非常少, 官方的文档基本只写了api, 一个例子都没有, 很多时候具体怎么用都是google来的, 或直接问misko,angular的作者.3，对IE6/7 兼容不算特别好, 就是可以用jQuery自己手写代码解决一些. React特性如下： 1.声明式设计：React采用声明模式，可以轻松描述应用。2.高效：React通过对DOM的模拟，最大限度地减少与DOM的交互。3.灵活：React可以与已知的库或框架很好地配合。 优点：1，速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。2，跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。3，模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。4，单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。5，同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。6，兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。缺点：1，React本身只是一个V而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。 8.对比一下jquery和vuejs jquery：对HTML的操作。绑定事件。请求数据。更多是以事件为入口去处理HTML。操作细腻。不过维护起来累 vuejs：逻辑简单，代码量少，组件化。根据页面的功能定义，构造出属于它的数据。需要事件触发，再编写起方法。基本的方法是数据的处理。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"},{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"面试题","slug":"面试题","permalink":"http://github.com/tags/面试题/"}]},{"title":"面试题整理（js篇）(一)","slug":"整理一些常见的面试题","date":"2018-04-27T05:38:32.766Z","updated":"2018-05-03T13:30:08.550Z","comments":true,"path":"2018/04/27/整理一些常见的面试题/","link":"","permalink":"http://github.com/2018/04/27/整理一些常见的面试题/","excerpt":"经常有大佬问起这方面的问题，现在整理其他博客文章重要知识点，多多背诵","text":"经常有大佬问起这方面的问题，现在整理其他博客文章重要知识点，多多背诵 1.基本数据类型五种： Undefined、 Null、 String、 Number、 Boolean(数组、函数都属于对象)(undefined表示变量声明但未初始化时的值，javascript解释器不知道这是什麽东西,会抛出”未定义”的错误null表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null值表示一个空对象指针，意思是你定义了它,但它没有分配内存空间) 2.JavaScript之面向对象的属性和特征 对象的本质：无序属性的集合，其属性可以包含基本值、对象或者函数；即对象是一组没有特定顺序的值，对象的每个属性或方法都有一个名字，而这个名字都映射到一个值。故对象的本质是一个散列表：其中是一组名值对，值可以是数据或函数。 对象的包含：数据属性和访问器属性，他们的区别如下： 数据属性: 一般用于存储数据数值，访问器属性不包含数据值； 访问器属性： 多用于get/set操作，访问器属性不能直接定义，必须使用Object.defineProperty()来定义，且该属性具有set和ger特性。console对象的时候可看。 3.闭包知识点 形成原理：嵌套函数被返回，被外界的变量引用，或者作为外部属性时，形成闭包。形成之后，原本被调用的属性变量（调用后会被垃圾回收）都能再次被使用,闭包就是能够读取其他函数内部变量的函数。 作用（优点） 实现共有变量 可做缓存 保护函数内变量安全，加强封装性，使属性私有化 模块化开发，防止污染全局变量 缺点： 闭包形成，导致原有的作用域链不释放，造成内存泄漏 占用内存 内存泄漏原因： 在闭包的作用域链中引用了HTML元素，导致未释放内存 出现了循环引用 4.html页面是如何呈现出来的（或者说经历了哪些步骤）JavaScript回流（reflow） 与重绘（repaint） 如何呈现： 1，html文档加载后生成dom树（包括display： none元素）； 2，在DOM树的基础上配合css样式结构体生成render树（不包含display:none;、head节点，包含visibility:hidden;节点），即页面中的占位确定了,最后绘制页面（也叫渲染），不会改变页面布局的一些属性：color、背景色等。 重绘(repaint) 更新页面元素的属性引起的，如颜色、透明度等不会改变页面布局而需要重新渲染的。 回流（reflow） render树中部分或全部元素的尺寸、布局、隐藏等(内容、结构、位置)改变引起的。每个页面至少有一次回流（即初始构建页面时），成本较高。 5.HTTP状态码：1.消息 2.成功 3.重定向 4.请求错误 5.服务器错误 304：响应禁止包含消息体，如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 305：被请求的资源必须通过指定的代理才能被访问。 400：语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求，或者请求参数有误。 403：服务器已经理解请求，但是拒绝执行它。 404：请求失败，请求所希望得到的资源未被在服务器上发现。 500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 6.Call（）和apply（） 先认识一下构造函数： 12345 function showname()&#123; this.name=\"zygg\"；&#125;var qq=new showname();console.log(qq.name); call(),apply()可以扩张函数赖以运行的作用域，改变函数内部的this指向，区别就是传参不同call（thisObj，Object）apply（thisObj，【argArray】） 12345678window.firstName = \"diz\"; window.lastName = \"song\"; var myname = &#123; firstName: \"my\", lastName: \"Object\" &#125;; function show() &#123; console.log(\"Hello \" + this.firstName + \" \" +this.lastName, \" glad to meet you!\"); &#125; show(); show.call(myname);//如果不这样写，对象myname是没法调用函数 show()的。 7.浅谈js继承继承是指一个对象直接使用另一对象的属性和方法实现方法： 对象冒充 call（）与Apply（） 原型链方式 js中每个对象均有一个隐藏的proto属性，一个实例化对象的proto属性指向其类的prototype方法，而这个prototype方法又可以被赋值成另一个实例化对象，这个对象的proto又需要指向其类，由此形成一条链。 那么proto是什么？我们在这里简单地说下。每个对象都会在其内部初始化一个属性，就是proto，当我们访问一个对象的属性 时，如果这个对象内部不存在这个属性，那么他就会去proto里找这个属性，这个proto又会有自己的proto，于是就这样 一直找下去，也就是我们平时所说的原型链的概念。 8.事件监听机制（冒泡和捕获） 事件捕获：事件从最上一级标签开始往下查找（父到子），直到捕获到事件目标（target）。 事件冒泡：事件从事件目标（target）开始，从下往上冒泡直到页面的最上一级标签。假设一个元素div，它有一个下级元素p。123&lt;div&gt; &lt;p&gt;元素&lt;/p&gt;&lt;/div&gt; 这两个元素都绑定了click事件，如果用户点击了p，它在div和p上都触发了click事件，那这两个事件处理程序哪个先执行呢？如div先触发，这就叫做事件捕获。如p先触发，这就叫做事件冒泡。 IE只支持事件冒泡，其他主流浏览器两种都支持。 程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。 事件的传播是可以阻止的： 在W3c中，使用stopPropagation（）方法 在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~ propagation 【传播，蔓延】 阻止事件的默认行为，例如click a标签后的跳转~ 在W3c中，使用preventDefault（）方法； 在IE下设置window.event.returnValue = false; 9.js事件委托 “事件处理程序过多”问题的解决方案就是事件委托。 事件委托利用的是事件冒泡机制，只制定一事件处理程序，就可以管理某一类型的所有事件（使用事件委托，只需在DOM树中尽量最高的层次上添加一个事件处理程序）。 这里要用到事件源：event 对象，需要用到target属性，其 事件属性可返回事件的目标节点（触发该事件的节点）123456oUl.onmouseover = function(ev)&#123; var target = ev.target if(target.nodeName.toLowerCase() == \"li\")&#123; target.style.background = \"red\"; &#125; &#125; 10.js实现类 构造函数： 由于js类的定义方法和函数的定义方法一样，所以定义构造函数的同时就定义了类。构造函数内的方法和属性也就是类中的方法和属性。 原型 该方式利用了对象的prototype属性。首先定义了一个空函数，然后通过prototype属性来定义对象的属性。调用该函数时，原型的所有属性都会立即赋予要创建的对象 11.js自定义事件 js自定义事件用处较多，最主要的就是实现观察者模式.观察者模式( 又叫发布者-订阅者模式 )应该是最常用的设计模式之一。平时接触的dom事件. 也是js和dom之间实现的一种观察者模式.观察者模式举例：div.onclick = function click (){ alert ( ‘’click’ )}只要订阅了div的click事件. 当点击div的时候, function click就会被触发.Div为发布者，click事件为订阅者 自定义事件例子：123456789&lt;script src=\"Scripts/jquery-2.1.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('body').on('someclick', function () &#123; console.log('被点击了~~'); &#125;); $('body').trigger('someclick'); &#125;); &lt;/script&gt; on（）是jQuery中的类似于bind（），live（），delegate（）等绑定事件的方法。 trigger() 方法触发被选元素的指定事件类型。先给固定元素绑定一个自定义事件”someclick”，然后必须通过trigger（）来使自定义事件可以使用。 Trigger【引发，触发;】 12.回调函数函数a有一个参数，这个参数是个函数b，当函数a执行完以后执行函数b。那么这个过程就叫回调。函数b是你以参数形式传给函数a的，那么函数b就叫回调函数。回调函数可以继续扩展一个函数的功能，可以是程序非常灵活。12345678910function zy(callback)&#123; alert(\"开始\"); callback(); &#125; function zygg()&#123; alert(\"我是回调函数\"); &#125; function test()&#123; zy(zygg) &#125; 13.编程题 有以下两个函数，定义一个对象使其拥有这两个函数属性。 12345678910function mobile()&#123; return 'mobile'; &#125; function phone()&#123; return 'phone'; &#125; var a = &#123;&#125;; a.mobile = mobile(); a.phone = phone(); console.log(a); 数组去重 123456789101112var arr = ['a','g','q','d','a','e','q']; Array.prototype.unique = function()&#123; for(var i = 0; i &lt; this.length; i++)&#123; for(var j = i+1; j &lt; this.length; j++)&#123; if(this[i] == this[j])&#123; this.splice(j,1); &#125; &#125; &#125; return this; &#125;; console.log(arr.unique()); 编写一个函数fn(Number n),将数字转为大写输出，如输入123，输出一百二十三。(这题考察了正则表达式还有数组的操作。) 12345678910111213141516171819function fn (n) &#123; if(!/^([1-9]\\d*)/.text(n))&#123; return '非法数据'; &#125; var unit = '千百十亿千百十万千百十个'； if(n.length &gt; unit.length)&#123; return '数据过长'; &#125; var newStr = ''; var nlength = n.length; unit = unit.substr(unit.length - nlength); for(var i = 0; i &lt; nlength; i++)&#123; newStr += '零一二三四五六七八九'.charAt(n[i]) + unit.charAt(i); &#125; newStr = newStr.substr(0,newStr.length-1); newStr = newStr.replace(/零(千|百|十)/g,'零').replace(/(零)+/g,'零').replace(/零(亿|万)/g,'$1'); return newStr;&#125; console.log(fn('205402002103')); 4.考察闭包12345678910111213141516var x = 20; var a = &#123; x : 15, fn : function()&#123; var x = 30; return function()&#123; return this.x; &#125;; &#125; &#125;; console.log(a.fn()); console.log((a.fn())()); console.log(a.fn()()); console.log(a.fn()() == (a.fn())()); console.log(a.fn().call(this)); console.log(a.fn().call(a)); 先说一下输出的答案：1）function(){return this.x;}2)203）204）true5）206)15这道题中的this都是指向windows，所以this.x的值都为20，第1、2、3、4种情况都很好理解，到第五第六种考察了call这个函数，call的用途：// 1. 替换函数运行环境中的this// 2. 传递参数// 3. 运行函数所以第六种是把this指向了a对象，所以输出的是a.x就为15。 5.编写一个函数fn(Number n),将数字转为大写输出，如输入123，输出一百二十三123456789101112131415161718function fn(n)&#123; if(!/^([1-9]\\d*)/.test(n))&#123; return '非法数据'; &#125; var unit = '千百十亿千百十万千百十个'; if(n.length &gt; unit.length)&#123; return '数据过长'; &#125; var newStr = ''; var nlength = n.length; unit = unit.substr(unit.length - nlength); for(var i = 0; i &lt; nlength; i++)&#123; newStr += '零一二三四五六七八九'.charAt(n[i]) + unit.charAt(i); &#125; newStr = newStr.substr(0,newStr.length-1); newStr = newStr.replace(/零(千|百|十)/g,'零').replace(/(零)+/g,'零').replace(/零(亿|万)/g,'$1'); return newStr; &#125; 这题考察了正则表达式还有数组的操作。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://github.com/tags/JavaScript/"},{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"面试题","slug":"面试题","permalink":"http://github.com/tags/面试题/"}]},{"title":"小功能插件","slug":"小功能插件代码","date":"2018-04-26T13:42:17.000Z","updated":"2018-04-27T04:00:35.907Z","comments":true,"path":"2018/04/26/小功能插件代码/","link":"","permalink":"http://github.com/2018/04/26/小功能插件代码/","excerpt":"一些常见的插件功能代码加一个牛逼哄哄的网站","text":"一些常见的插件功能代码加一个牛逼哄哄的网站 1. 插入框实现代码在线运行如下（输入代码）： window.onload=function(){ var run=document.getElementById('run'); var code=document.getElementById('code'); run.onclick=function(){ var win=window.open('about:blank','_blank'); win.document.write(code.value); //强制从缓存区输出内容 win.document.close(); } } 源码为12345678910111213141516&lt;textarea id=&quot;code&quot; cols=&quot;40&quot; rows=&quot;10&quot; style=&quot;width:90%;background-color:#eee;&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type=&quot;butoon&quot; value=&quot;运行代码&quot; id=&quot;run&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var run = document.getElementById(&apos;run&apos;); var code = document.getElementById(&apos;code&apos;); run.onclick = function () &#123; var win = window.open(&apos;about:blank&apos;,&apos;_blank&apos;); win.document.write(code.value); //强制从缓冲区输出内容 win.document.close(); &#125; &#125;&lt;/script&gt; 测试一下(copy下面代码),运行试试看12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;text&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;hello world&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 重大发现还有就是今天好像发现了一个很666的东西codepenCodePen.io:网站前端设计开发平台是一个针对网站前端代码设计的开发工具，提供多种效果的网站前端代码设计工具，丰富的案例特效，用户可以demo的基础上开发自己的前端设计。~~贼帅~ codepen 官网codepen 中文官网2016 排行前100的酷炫设计 慢慢研究学习","categories":[],"tags":[{"name":"小插件","slug":"小插件","permalink":"http://github.com/tags/小插件/"},{"name":"codepen","slug":"codepen","permalink":"http://github.com/tags/codepen/"}]},{"title":"hexo搭建个人博客总结（三）","slug":"hexo搭建个人博客总结（三）","date":"2018-04-24T17:44:44.000Z","updated":"2019-08-28T07:00:54.918Z","comments":true,"path":"2018/04/25/hexo搭建个人博客总结（三）/","link":"","permalink":"http://github.com/2018/04/25/hexo搭建个人博客总结（三）/","excerpt":"为自己的博客搭建更多功能","text":"为自己的博客搭建更多功能 云储存搭建 评论功能的插入 统计功能（部分参考他人博客总结） 1.七牛云图床(供博客图床使用，可选择性进行)尴尬了，网站要域名备案，即用不了了，之前的图片链接都作废了，还是放在本地的文件图片文件夹里吧。。。。还有得把用到的图片链接换回来。。。。 七牛云介绍1挺好的一个云服务网站，注册后可以免费领取10G免费空间等等，可以将博客中需要使用的图片上传到注册的服务器上，可以加快图片的加载速度，至少比在github上的速度快很多。 七牛云账号创建和设置1进入七牛云官网注册，按照流程进行，登陆后选择对象存储，这里需要先实名认证，此时可以选择绑定域名(需要已备案)，在内容管理中可以上传图片(需实名注册)，复制图片的链接即可在再网页上访问 下面试试看是否外链能用了看来是OK了！ 评论功能的插入凉凉，第一次添加“评论功能”宣告失败弄完后本地服务器运行好久，最后无法加载。。。。。真滴难受，熬到三点半想搞定这个，结果一场空现在还要恢复都还没添加时的状态，尴尬代码等明天再重新在git上下载吧！就换回shemes–yilia全部替换回来。。。。。。睡觉。。。。。。 2018-04-25终于改回到原来的样子了，妈呀，好麻烦这个，心态崩了！！！存在好多问题，所以评论问题打算暂时留着，等心态调整好了再来弄弄看，现在搞得头好晕。。。。。。（很难改的，最后总结重新安装==。。。。）网上好多推荐这个https://github.com/litten/hexo-theme-yilia好难看懂 2018-04-27总结一下添加评论功能的艰辛 那些评论的网站不是关了，就是要备案（高逼格） 最后想了想，其实也不怎么需要这个评论，所以打算不弄了 等看到一些真的简单好用的再来推荐 统计功能yilia主题中集成了google_analytics和baidu_analytics的统计功能，选择一种进行注册，绑定域名即可，但是页面不会有显示的效果，此处，我集成了一个第三方统计插件-不蒜子,按照官网提示操作步骤进行即可，详细如下： 1.打开\\themes\\yilia\\layout_partial目录下的footer.ejs文件，首先最最后copy以下一行代码： 1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2.此处为了方便灵活管理，可以通过配置文件控制显示，选择合适的位置(我选择加在footer.ejs中)，可以加入如下配置 123456789&lt;div class=&quot;footer-left&quot;&gt;&amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt;&lt;% if (theme.site_count)&#123; %&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站被踩过&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;% &#125; %&gt;&lt;% if (theme.user_count)&#123; %&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;被&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人踩过&lt;/span&gt;&lt;% &#125; %&gt;&lt;/div&gt; 3.预览效果为： 4.在文章标题后面显示文章的访问量，在\\themes\\yilia\\layout\\_partial下的article.ejs中的以下位置加入： 123456789101112131415&lt;header class=&quot;article-header&quot;&gt;&lt;%- partial(&apos;post/title&apos;, &#123;class_name: &apos;article-title&apos;&#125;) %&gt;&lt;% if (theme.page_count &amp;&amp; !index)&#123; %&gt; &lt;/br&gt; &lt;a class=&quot;article-count-a-tag&quot; href=&quot;javascript:void(0);&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; class=&quot;article-count-a-span&quot;&gt; 被偷看了：&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;/a&gt;&lt;% &#125; %&gt;&lt;% if (!post.noDate)&#123; %&gt;&lt;%- partial(&apos;post/date&apos;, &#123;class_name: &apos;archive-article-date&apos;, date_format: null&#125;) %&gt;&lt;% &#125; %&gt;&lt;/header&gt; 5.此处有一个小细节就是判断条件中加入 !index 判断条件，在主页时不显示，点击进入某文章时才显示统计的效果，最后还需要在…\\themes\\yilia\\source的main.css中加入自定义的class，我定义的为： 12.article-count-a-tag&#123;color:gray;font-size:14px;&#125;.article-count-a-span&#123;color:#ef7522;font-size:14px;&#125; 6.最终效果为： 统计功能还没进行验证已验证，但总觉得哪里怪怪的 哇！看到了一个好厉害的博客（yilia主题的）里面好多内容不蒜子博客不蒜子文档抽时间好好学 自我感觉博客界面刚开始到这样就基本OK了，一些美化的工作就等后面有发现再更新，hexo就此告一段落了。。。。。","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"jQuery-UI学习进度","slug":"jQuery-UI","date":"2018-04-23T16:22:52.619Z","updated":"2018-04-26T15:06:19.961Z","comments":true,"path":"2018/04/24/jQuery-UI/","link":"","permalink":"http://github.com/2018/04/24/jQuery-UI/","excerpt":"jQueryUI 是以 jQuery 为基础的开源 JavaScript 网页用户界面代码库。","text":"jQueryUI 是以 jQuery 为基础的开源 JavaScript 网页用户界面代码库。 概述jQueryUI 是以 jQuery 为基础的开源 JavaScript 网页用户界面代码库。包含底层用户 交互、动画、特效和可更换主题的可视控件。我们可以直接用它来构建具有很好交互性的 web 应用程序。 相关内容多去看jQuery文件夹,熟悉对于方法属性的用法，需要用到时记得去查 之前已完成学习的知识点 创建header区 对话框UI 按钮样式的修改 创建注册表单 工具提示（默认内容提示） 2018-04-24学习 主动补全功能实现 邮箱主动补全 日历UI 下午 15:09 继续学习 验证插件 验证注册表单2018-04-26学习 ajax表单插件（接下来讲到了数据库的搭建，需不需要去了解一下数据库？？？） （想了一下，还是暂时先留着！！！） （先了解性地刷完下面的课程，到时再回头仔细看一遍 == window.onload=function(){ var run=document.getElementById('run'); var code=document.getElementById('code'); run.onclick=function(){ var win=window.open('about:blank','_blank'); win.document.write(code.value); //强制从缓存区输出内容 win.document.close(); } }","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://github.com/tags/日记/"},{"name":"学习进度","slug":"学习进度","permalink":"http://github.com/tags/学习进度/"}]},{"title":"hexo搭建个人博客总结（二）","slug":"hexo搭建个人博客总结（二）","date":"2018-04-23T13:42:17.000Z","updated":"2019-08-28T07:01:20.990Z","comments":true,"path":"2018/04/23/hexo搭建个人博客总结（二）/","link":"","permalink":"http://github.com/2018/04/23/hexo搭建个人博客总结（二）/","excerpt":"hexo搭建个人博客总结–进阶","text":"hexo搭建个人博客总结–进阶 hexo项目介绍注意冒号后面的空格 1.目录结构介绍12345678910deploy #需要部署的文件node_modules #Hexo插件public #生成的静态网页文件scaffolds #模板source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里_drafts #草稿_posts #文章themes #主题_config.yml #全局配置文件package.json 2.全局配置文件介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117title: 个人博客 //页面标题subtitle: 玉面小飞龙 //小标题description: 贼溜 //描述author: Little Dragon //作者language: zh-CN //语言timezone: //时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://halomelody.github.io/ //个人域名root: / //根目录permalink: :year/:month/:day/:title/ //文章创建后生成的目录结构permalink_defaults:# Directory //变量与目录的对应情况source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: //分页设置 path: &apos;&apos; per_page: 5 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia //主题配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: //发布对应的github账号 type: git repo: git@github.com:haloMelody/haloMelody.github.io.git branch: master (上面有回答前面问题3的答案)123456# order_by: Posts order. (Order by date descending by default)index_generator: //分页设置 path: &apos;&apos; per_page: 5 order_by: -date 2.一些主题功能1.弹框配置首先需要具备hexo中nodeJS版本高于6.2才可以生效（下载最新的nodeJS-&gt;得到的hexo可以即可满足，可以通过hexo -v查看nodeJS版本）在根目录配置文件中添加如下内容：123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 2.文章分类12title: hexo+github创建个人博客--深入篇categories: 瞎搞 3.标签配置12345title: hexo+github创建个人博客--深入篇tags: - hexo - github - yilia 4.目录配置12title: hexo+github创建个人博客--深入篇toc: true 5.内容过长隐藏（回答前面的问题2）主题配置文件中配置截断显示的文字，excerpt_link: more ,此处显示为more在文章中键入该注释，即可在该位置生效：1&lt;!-- more --&gt; 待续、、、、、、","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"hexo搭建个人博客总结","slug":"hexo搭建个人博客总结","date":"2018-04-23T08:42:17.000Z","updated":"2019-08-28T07:31:24.385Z","comments":true,"path":"2018/04/23/hexo搭建个人博客总结/","link":"","permalink":"http://github.com/2018/04/23/hexo搭建个人博客总结/","excerpt":"下载与安装git与node.js安装hexo","text":"下载与安装git与node.js安装hexo 以上皆可参考网站： https://blog.csdn.net/ainuser/article/details/77609180里面都有详细的记载 说一些出现的问题1.hexo server在启动服务那里，一般修改主题后都要经过下列三个步骤 –&gt;hexo clean –&gt;hexo generate –&gt;hexo server 而hexo server就是启动本地服务器（http://localhost:4000），点击可预览博客页面 1234 林泽坚@DESKTOP-BP2UH3E MINGW64 /d/Hexo$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 像上面这样，此时不能关闭这里，才能启动等到调试完毕，要上传时再ctrl+c停止，然后 hexo deploy上传 2.购买域名这里因为git有免费的域名，所以这里不用这么麻烦，自行跳过。。。。。 3、其它紧跟网站教程就OK了 进阶–开始使用hexo1.更改主题1、hexo主题官网在这里寻找喜欢的主题排版样式，复制压缩包网址，在根目录那里启动 git bash here 手动输入12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载完毕 接着在根目录那里修改_config.yml文件1theme: next 下面介绍一下主题yilia将主题配置到个人博客中，在根目录的全局配置文件中修改此变量（主题项目中也有_config.yml配置文件）主题配置文件介绍（摘要）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156# Header，主题页面显示链接menu: 主页: / 所有文章: /archives# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 1# 打赏wordingreward_wording: 老板大气，谢谢老板！# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: http://ou36vgj5u.bkt.clouddn.com/image/blog/alipay.JPG# 微信二维码图片地址weixin: http://ou36vgj5u.bkt.clouddn.com/image/blog/wechatpay.JPG# 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos;# 是否有快速回到顶部的按钮top: true# Miscellaneous，网站统计baidu_analytics: &apos;24451a8b853bb443019686be21dfdff4&apos;google_analytics: &apos;&apos;favicon: http://ou36vgj5u.bkt.clouddn.com/image/blog/fav.ico#你的头像urlavatar: http://ou36vgj5u.bkt.clouddn.com/image/blog/head.jpg#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#disqus_shortname: halomelody# slider的设置slider: # 是否默认展开tags板块 showTags: true# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;文章查找&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos; #tagcloud: &apos;标签&apos;#friends:aboutme: little dragon# 页面统计 true为开启#page_count: false# 站点统计 true为开启#site_count: true 将 next（原主题） 修改为相对应的主题就行最后三部曲（ –&gt;hexo clean –&gt;hexo generate –&gt;hexo deploy）搞定 2.修改头像在对应的主题文件夹内进行修改,较简单参考网址https://jingyan.baidu.com/album/c85b7a64b6a68c003bac9509.html?picindex=6注意： 这里要特别说明两点a ： 网页中用到的图片都是放在这里指出的文件夹内 b ： 图片地址都是： [/img/图片名] 3.内容编辑（写博客）开启git bash herehexo new page “name” #新建一个博客主页面hexo new “name” #新建文章接着这些东西放在哪里呢？这是最重要的，这样才能进行编写下面流程：1根目录下的 source--&gt; _post(没自己命名的)（或自己hexo new page &quot;name&quot;的name）--&gt;....md(这些md文件就是文章了) 了解md==markdowm语法编写请参考之前的博客文章原文档–Markdowm语法 4.问题解决1.静态博客的搭建2.主题的修改3.修改头像4.内容编辑 5.问题待解决1.在这里，但我们已经建立了一个 hexo new page “name” #新建一个博客主 后再次新建一个hexo new page “name2” 这时博客主页不显示name2的文件内容？？？？？求大神指点！！！2.如何隐藏过长的文章(hexo搭建个人博客总结（二）已解决)3.如果文章数量多了，如何实现换页(hexo搭建个人博客总结（二）已解决)4.相册的实现5.云储存搭建6.评论功能的插入7.统计功能","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"},{"name":"hexo","slug":"hexo","permalink":"http://github.com/tags/hexo/"}]},{"title":"Markdowm","slug":"Markdowm","date":"2018-04-22T08:32:23.000Z","updated":"2018-05-14T16:34:46.591Z","comments":true,"path":"2018/04/22/Markdowm/","link":"","permalink":"http://github.com/2018/04/22/Markdowm/","excerpt":"概述Markdown 的目标是实现「易读易写」。","text":"概述Markdown 的目标是实现「易读易写」。Markdown语法的目标是：成为一种适用于网络的书写语言。Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应HTML标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown的理念是，能让文档更容易读、写和随意改。HTML是一种发布的格式，Markdown是一种书写的格式。就这样，Makdown 的格式语法只涵盖纯文本可以涵盖的范围。即HTML的语法是可以在markdowm这里使用的，如果不想学md里面的语法，那就直接用html的就行！但如果会用还是好一点的、、、、、","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"http://github.com/tags/知识点/"}]},{"title":"基本搞定博客","slug":"搞定","date":"2018-04-21T09:44:44.000Z","updated":"2018-04-22T12:59:15.007Z","comments":true,"path":"2018/04/21/搞定/","link":"","permalink":"http://github.com/2018/04/21/搞定/","excerpt":"","text":"露出老母亲般欢喜的笑容 烦烦躁躁还是成功了，得到的经验就是要多查百度，笔记也是要记下的，不然老是要去重新查找，是有点费时间的，继续加油！！！","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"http://github.com/tags/日记/"}]},{"title":"原文档--Markdowm语法","slug":"原文档--Markdowm语法","date":"2018-04-19T17:31:43.804Z","updated":"2019-05-20T07:20:44.953Z","comments":true,"path":"2018/04/20/原文档--Markdowm语法/","link":"","permalink":"http://github.com/2018/04/20/原文档--Markdowm语法/","excerpt":"Welcome","text":"Welcome h1h2h3h4h5h62.分级标题一级标题二级标题注：= - 最少可以只写一个，兼容性一般 3.直接写文字，相当于p标签dhdhdhdhhhhd直接换行 空格不能保留biansi(后面要加上跳转地址)More info: Writing## 4.引用代码1(单行式)&gt; hello world!代码2(多行式)&gt; hello world!hello world!hello world!代码3(多层嵌套)&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc## 5.行内标记注：用 标记代码块将变成一行 标记之外hello world标记之外## 6.代码块注：与上行距离一空行12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;代码3(自定义语法)注：根据不同的语言配置不同的代码着12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num);1$ hexo new \"My New Post\" 在这里可以保留代码形式与黑色背景## 7.插入链接代码1(内链式)1[百度1](http://www.baidu.com/&quot; 百度一下&quot;)&#123;:target=&quot;_blank&quot;&#125;代码2(引用式)12[百度2][2]&#123;:target=&quot;_blank&quot;&#125;[2]: http://www.baidu.com/ &quot;百度二下&quot;## 8.插入图片代码1(内链式)1![](./01.png &apos;描述&apos;)代码2(引用式)12![name][01][01]: ./01.png &apos;描述&apos;## 9.插入图片带有链接代码1234[![](./01.png &apos;百度&apos;)](http://www.baidu.com)&#123;:target=&quot;_blank&quot;&#125; // 内链式[![](./01.png &apos;百度&apos;)][5]&#123;:target=&quot;_blank&quot;&#125; // 引用式[5]: http://www.baidu.com### 10.排序列表1. 有序列表（代码）1231. one2. two3. three1. one2. two3. three注意： 序列. 后面保持空格（好像都要有个空格） 无序列表123* one* two* three one two three上面两种都可以进行互相嵌套，特别注意空格。 11.分隔符注：最少三个 --- 或 ***或 * * *123***---* * * 演示 12.语义标记斜体 *斜体* 斜体斜体 _斜体_ _斜体_加粗 **加粗** 加粗加粗+斜体 ***加粗+斜体*** 加粗+斜体加粗+斜体 **_加粗+斜体_** 加粗+斜体删除线 ~~删除线~~ 删除线 13.更多看文档https://www.jianshu.com/p/b03a8d7b1719https://www.appinn.com/markdown/ 其实一些自己想要的样式还是自己用html+css自定义搞定！","categories":[],"tags":[{"name":"Markdowm语法","slug":"Markdowm语法","permalink":"http://github.com/tags/Markdowm语法/"},{"name":"md知识点","slug":"md知识点","permalink":"http://github.com/tags/md知识点/"}]}]}